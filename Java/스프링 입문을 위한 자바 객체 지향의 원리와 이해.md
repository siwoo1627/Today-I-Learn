### 02장: 자바와 절차적/ 구조적 프로그래밍


JDK:자바 개발 도구
JRE: 자바 실행 환경
JVM: 자바 가상 기계
* JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구현된다.

스태틱 영역:클래스의 놀이터
스택 영역: 메서드들의 놀이터
힙 영역: 객체들의 놀이터

#### 멀티 스레드 / 멀티 프로세스의 이해

* 멀티 스레드의 T메모리 모델은 스택 영억을 스레드 개수만큼 분할해서 쓰는 것이다.
  * 멀티 스레드에서 전역변수를 사용할 경우 공유 스태틱영역의 전역변수를 사용할 경우 다른 스레드에서도 값이 적용된다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/0eb6e709-5e12-4638-a439-700870d053b8)

* 멀티 프로레스는 다수의 T메모리를 갖는 구조이다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/a22e9b5b-1266-4ba0-9546-ee3895fd8f3e)

***

### 03장: 자바와 객체 지향

객체 지향의 4 대 특성 - 캡! 상추다

* 캡: 캡슐화
* 상: 상속
* 추: 추상화
* 다: 다형성

**추상**: 여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

**클래스**: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념

> 클래스:객체 = 펭귄:뽀로로 = 사람:김연아 = 쥐:미키마우스

객체(Object) = 클래스의 인스턴스

```java
사람 홍길동 = new 사람();
클래스 객체_참조_변수 = new 클래스();
```

* 사람이라는 클래스(분류)를 이용해 유일무이하고 새로운 하나의 사람(객체)을 만들어 홍길동(객체 참조 변수)이라는 이름을 지어준 것
* `new 사람()`: 클래스의 인스턴스를 하나 만들어 힙에 배치한다.
* `사람` 객체에 대한 주소(포인터)를 참조변수 `홍길동`에 할당한다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/cfebd793-a09c-43c0-abec-3f418ffd3f96)

#### 클래스 멤버 vs. 객체 멤버 = static 멤버 vs. 인스턴스 멤버

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/3190acfc-aefa-4e2a-9c01-8f1a7f06a176)

#### 추상화

: 구체적인 것을 분해해서 관심영역(애플리케이션 경계)에 있는 특성만 가지고 재조합 한 것 = 모델링

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/5713821f-c837-4f3b-a99f-564a22c45485)

#### 상속

* 상속의 개념은 부모-자식이 아닌, 상위-하위 또는 슈퍼클래스-서브클래스 관계이다.

* 계층도/조직도 x, 분류도 o
* 상속은 is a kind of 관계이다.
  * 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류이다.
  * 펭귄 is a kind of 동물 -> 펭귄은 동물의 한 분류이다.

>  클래스명은 분류스럽게, 객체명은 유일무이한 사물처럼 작성

**인터페이스**

* 구현 클래스 is able to 인터페이스 -> 구현 클래스는 인터페이스 할 수 있다.
  * 고래는 헤엄칠 수 있다.

상위클래스는 물려줄 특성이 많을수록 좋고(리스코프 치환 원칙), 인터페이스는 구현을 강제할 메서드 개수가 적을수록 좋다(인터페이스 분할 원칙)

```java
Penguin pororo = new Penguin();
// 펭귄 한 마리가 태어나니 펭귄 역할을 하는 pororo라 이름을 지었다.
pororo.name = "뽀로로";
// pororo의 name을 "뽀로로" 라 하자.
pororo.habitat = "남극";
// pororo의 habitat(서식지) 를 "남극"이라 하자.
pororo.showName( );
// pororo야 너의 이름을 보여다오
pororo.showHabitat();
// pororo야 너의 서식지를 보여다오.
```

#### 다형성


오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메소드를 재정의

오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

#### 캡슐화

* private[-]: 본인만 접근 가능

* defalt[~]: 같은 패키지 내의 클래스에서 접근 가능
* protect[#]: 상속/같은 패키지 내의 클래스에서 접근 가능

* public[+]: 모두가 접근 가능

상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조변수를 이용해 접근해야 한다.

정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

***

### 04장: 자바가 확장한 객체 지향

#### abstract 키워드 - 추상 메서드와 추상 클래스

* 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다.
* 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제
* 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다.

#### 생성자

: 반환값이 없고 클래스명과 같은 이름을 가진 메서드를 생성자라고 한다. -> 객체를 만드는 메서드라고 해서 객체 생성자 메서드라고 한다.

#### final 키워드

final 클래스 -> 상속 금지

final 변수 -> 변경 불가능한 상수

final 메서드 -> 오버라이딩 금지

#### instanceof 연산자

: 인스턴스=클래스를 통해 만들어진 객체, instanceof는 객체가 특정 클래스의 인스턴스인지 물어보는 연산자

#### interface 키워드와 implements 키워드

인터페이스에 선언한 변수와 메서드는 자동으로 `public static fianl`, `public abstract` 를 자동으로 붙여준다.

#### this 키워드

* 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
* 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this 접두사를 사용한다.
* 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적변수를 사용하려면 클래스명을 접두사로 사용한다.

***

### 05장: 객체 지향 설계 5원칙 - SOLID

#### SRP(Single Responsibillity Principle) - 단일 책임 원칙

: 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

* 클래스/속성/패키지/모듈 등을 역할과 책임에 따라 분리한다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/d49c5827-0310-449e-86d6-d4bcd6f43c16)

#### OCP(Open Closed Principle) - 개방 폐쇄 원칙

: 자신의 확장에는 열려있고, 주변의 변화에는 닫혀 있어야 한다.

* 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충장치로 인해 변화에 영향을 받지 않는다.
  * 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀있고, 데이터베이스를 교체한다는 것은 자신의 확장에는 열려있는 것이다.

* JDBC를 이용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Conection을 설정하는 부분 외에는 따로 수정할 필요가 없다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/890b1275-b30a-465c-914b-62d67090c78e)

#### LSP(Liskov Substituion Principle) - 리스코프 치환 원칙

: 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

> 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

* 하위 클래스 is a kind of 상위 클래스 -> 하위 분류는 상위 분류의 한 종류이다.
* 구현 클래스 is able to 인터페이스 -> 구현 분류는 인터페이스할 수 있어야 한다.

```java
아버지 춘향이 = new 딸( ); // 딸을 낳아서 이름을 춘향이라고 하는데 아버지 역할을 맡기고 있다. - LSP x
동물 뽀로로 = new 펭귄( ); // 펭귄 한마리 이름을 뽀로로라 이름을 짓고 동물 역할을 한다. - LSP o
```

춘향이는 아버지형 참조변수이므로 아버지 객체가 가진 행위(메서드)를 할 수 있어야 한다.

#### ISP(Interface Segregation Principle) - 인터페이스 분리 원칙

: 클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다.

* SPR와 ISP는 같은 문제에 대한 두가지 다른 해결책이다.

#### DIP(Dependency Inversion Principle) - 의존 역전 원칙

: 자신보다 변하기 쉬운 것에 의존하지 마라.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/f34b0fb8-d7da-490a-bbc7-15631b61178c)

* 자동차가 구체화된 스노우타이어/일반타이어/광폭타이어에 의존하는게 아닌 추상화된 타이어 인터페이스에 의존하게 함으로써 스노우타이어에서 일반타이어로 변경되어도 자동차는 영향을 받지 않는다.

***

### 06장: 스프링이 사랑한 디자인 패턴

어댑터 패턴(Adapter Pattern)

프록시 패턴(Proxy Pattern)

데코레이터 패턴(Decorator Pattern)

싱글턴 패턴(Singleton Pattern)

템플릿 메서드 패턴(Template Method Pattern)

팩터리 메서드 패턴(Factory Method Pattern)

전략 패턴(Strategy Pattern)

템플릿 콜백 패턴(Template Callback Pattern - 견본/회신 패턴)

스프링이 사랑한 다른 패턴들

~231p 금

***

### 07장: 스프링 삼각형과 설정 정보

IoC/DI - 제어의 역전/의존성 주입

프로그래밍에서 의존성이란?

스프링 없이 의존성 주입하기 1 - 생성자를 통한 의존성 주입

스프링 없이 의존성 주입하기 2 - 속성을 통한 의존성 주입

스프링을 통한 의존성 주입 - XML 파일 사용

스프링을 통한 의존성 주입 - 스프링 설정 파일(XML)에서 속성 주입

스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입

스프링을 통한 의존성 주입 - @Resource를 통한 속성 주입

스프링을 통한 의존성 주입 - @Autowired vs. @Resource vs. 태그

AOP - Aspect? 관점? 핵심 관심사? 횡단 관심사?

일단 덤벼 보자 - 실전편

일단 덤벼 보자 - 설명편

일단 덤벼 보자 - 용어편

일단 덤벼 보자 - POJO와 XML 기반 AOP

AOP 기초 완성 310

PSA - 일관성 있는 서비스 추상화

~314p 토

***

### 부록A: 스프링 MVC를 이용한 게시판 구축

A.1 URL과 @RequestMapping 연결하기

A.2 인메모리 DB HSQL 사용하기

A.3 VO와 MyBatis를 이용한 DAO 구현

A.4 서비스(Service) 구현

A.5 목록 구현

A.6 읽기 구현

A.7 새 글 구현

A.8 수정 구현

A.9 삭제 구현

A.10 리팩터링

~361p

***

###  부록B: 자바 8 람다와 인터페이스 스펙 변화

B.1 람다가 도입된 이유

B.2 람다란 무엇인가?

B.3 함수형 인터페이스

B.4 메서드 호출 인자로 람다 사용

B.5 메서드 반환값으로 람다 사용

B.6 자바 8 API에서 제공하는 함수형 인터페이스

B.7 컬렉션 스트림에서 람다 사용

B.8 메서드 레퍼런스와 생성자 레퍼런스

B.9 인터페이스의 디폴트 메서드와 정적 메서드

B.10 정리

~389p
