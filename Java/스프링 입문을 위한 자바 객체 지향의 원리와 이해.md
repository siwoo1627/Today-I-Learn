### 02장: 자바와 절차적/ 구조적 프로그래밍


JDK:자바 개발 도구
JRE: 자바 실행 환경
JVM: 자바 가상 기계
* JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구현된다.

스태틱 영역:클래스의 놀이터
스택 영역: 메서드들의 놀이터
힙 영역: 객체들의 놀이터

#### 멀티 스레드 / 멀티 프로세스의 이해

* 멀티 스레드의 T메모리 모델은 스택 영억을 스레드 개수만큼 분할해서 쓰는 것이다.
  * 멀티 스레드에서 전역변수를 사용할 경우 공유 스태틱영역의 전역변수를 사용할 경우 다른 스레드에서도 값이 적용된다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/0eb6e709-5e12-4638-a439-700870d053b8)

* 멀티 프로레스는 다수의 T메모리를 갖는 구조이다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/a22e9b5b-1266-4ba0-9546-ee3895fd8f3e)

***

### 03장: 자바와 객체 지향

객체 지향의 4 대 특성 - 캡! 상추다

* 캡: 캡슐화
* 상: 상속
* 추: 추상화
* 다: 다형성

**추상**: 여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

**클래스**: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념

> 클래스:객체 = 펭귄:뽀로로 = 사람:김연아 = 쥐:미키마우스

객체(Object) = 클래스의 인스턴스

```java
사람 홍길동 = new 사람();
클래스 객체_참조_변수 = new 클래스();
```

* 사람이라는 클래스(분류)를 이용해 유일무이하고 새로운 하나의 사람(객체)을 만들어 홍길동(객체 참조 변수)이라는 이름을 지어준 것
* `new 사람()`: 클래스의 인스턴스를 하나 만들어 힙에 배치한다.
* `사람` 객체에 대한 주소(포인터)를 참조변수 `홍길동`에 할당한다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/cfebd793-a09c-43c0-abec-3f418ffd3f96)

#### 클래스 멤버 vs. 객체 멤버 = static 멤버 vs. 인스턴스 멤버

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/3190acfc-aefa-4e2a-9c01-8f1a7f06a176)

#### 추상화

: 구체적인 것을 분해해서 관심영역(애플리케이션 경계)에 있는 특성만 가지고 재조합 한 것 = 모델링

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/5713821f-c837-4f3b-a99f-564a22c45485)

#### 상속

* 상속의 개념은 부모-자식이 아닌, 상위-하위 또는 슈퍼클래스-서브클래스 관계이다.

* 계층도/조직도 x, 분류도 o
* 상속은 is a kind of 관계이다.
  * 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류이다.
  * 펭귄 is a kind of 동물 -> 펭귄은 동물의 한 분류이다.

>  클래스명은 분류스럽게, 객체명은 유일무이한 사물처럼 작성

**인터페이스**

* 구현 클래스 is able to 인터페이스 -> 구현 클래스는 인터페이스 할 수 있다.
  * 고래는 헤엄칠 수 있다.

상위클래스는 물려줄 특성이 많을수록 좋고(리스코프 치환 원칙), 인터페이스는 구현을 강제할 메서드 개수가 적을수록 좋다(인터페이스 분할 원칙)

```java
Penguin pororo = new Penguin();
// 펭귄 한 마리가 태어나니 펭귄 역할을 하는 pororo라 이름을 지었다.
pororo.name = "뽀로로";
// pororo의 name을 "뽀로로" 라 하자.
pororo.habitat = "남극";
// pororo의 habitat(서식지) 를 "남극"이라 하자.
pororo.showName( );
// pororo야 너의 이름을 보여다오
pororo.showHabitat();
// pororo야 너의 서식지를 보여다오.
```

#### 다형성


오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메소드를 재정의

오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

#### 캡슐화

* private[-]: 본인만 접근 가능

* defalt[~]: 같은 패키지 내의 클래스에서 접근 가능
* protect[#]: 상속/같은 패키지 내의 클래스에서 접근 가능

* public[+]: 모두가 접근 가능

상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조변수를 이용해 접근해야 한다.

정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

***

### 04장: 자바가 확장한 객체 지향

#### abstract 키워드 - 추상 메서드와 추상 클래스

* 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다.
* 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제
* 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다.

#### 생성자

: 반환값이 없고 클래스명과 같은 이름을 가진 메서드를 생성자라고 한다. -> 객체를 만드는 메서드라고 해서 객체 생성자 메서드라고 한다.

#### final 키워드

final 클래스 -> 상속 금지

final 변수 -> 변경 불가능한 상수

final 메서드 -> 오버라이딩 금지

#### instanceof 연산자

: 인스턴스=클래스를 통해 만들어진 객체, instanceof는 객체가 특정 클래스의 인스턴스인지 물어보는 연산자

#### interface 키워드와 implements 키워드

인터페이스에 선언한 변수와 메서드는 자동으로 `public static fianl`, `public abstract` 를 자동으로 붙여준다.

#### this 키워드

* 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
* 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this 접두사를 사용한다.
* 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적변수를 사용하려면 클래스명을 접두사로 사용한다.

***

### 05장: 객체 지향 설계 5원칙 - SOLID

#### SRP(Single Responsibillity Principle) - 단일 책임 원칙

: 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

* 클래스/속성/패키지/모듈 등을 역할과 책임에 따라 분리한다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/d49c5827-0310-449e-86d6-d4bcd6f43c16)

#### OCP(Open Closed Principle) - 개방 폐쇄 원칙

: 자신의 확장에는 열려있고, 주변의 변화에는 닫혀 있어야 한다.

* 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충장치로 인해 변화에 영향을 받지 않는다.
  * 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀있고, 데이터베이스를 교체한다는 것은 자신의 확장에는 열려있는 것이다.

* JDBC를 이용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Conection을 설정하는 부분 외에는 따로 수정할 필요가 없다.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/890b1275-b30a-465c-914b-62d67090c78e)

#### LSP(Liskov Substituion Principle) - 리스코프 치환 원칙

: 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

> 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

* 하위 클래스 is a kind of 상위 클래스 -> 하위 분류는 상위 분류의 한 종류이다.
* 구현 클래스 is able to 인터페이스 -> 구현 분류는 인터페이스할 수 있어야 한다.

```java
아버지 춘향이 = new 딸( ); // 딸을 낳아서 이름을 춘향이라고 하는데 아버지 역할을 맡기고 있다. - LSP x
동물 뽀로로 = new 펭귄( ); // 펭귄 한마리 이름을 뽀로로라 이름을 짓고 동물 역할을 한다. - LSP o
```

춘향이는 아버지형 참조변수이므로 아버지 객체가 가진 행위(메서드)를 할 수 있어야 한다.

#### ISP(Interface Segregation Principle) - 인터페이스 분리 원칙

: 클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다.

* SPR와 ISP는 같은 문제에 대한 두가지 다른 해결책이다.

#### DIP(Dependency Inversion Principle) - 의존 역전 원칙

: 자신보다 변하기 쉬운 것에 의존하지 마라.

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/f34b0fb8-d7da-490a-bbc7-15631b61178c)

* 자동차가 구체화된 스노우타이어/일반타이어/광폭타이어에 의존하는게 아닌 추상화된 타이어 인터페이스에 의존하게 함으로써 스노우타이어에서 일반타이어로 변경되어도 자동차는 영향을 받지 않는다.

***

### 06장: 스프링이 사랑한 디자인[^1] 패턴

| 요리            | 객체 지향 프로그래밍(OOP) |
| --------------- | ------------------------- |
| 요리도구        | 4대 원칙(캡! 상추다)      |
| 요리도구 사용법 | 설계 원칙(SOLID)          |
| 레시피          | 디자인 패턴               |

#### 어댑터 패턴(Adapter Pattern)

: 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴

* 변환기(adapter): 서로 다른 두 인터페이스 사이에 통신이 가능하게 한다.
* JDBC/ODBC가 어댑터 패턴을 이용해 다양한 데이터베이스 시스템을 단일한 인터페이스로 조작할 수 있게 해준다.

```java
package adapterPattern;

public class ClientWithAdapter {
	public static void main(String[] args) {
		AdapterServicA asa1 = new AdapterServicA();
		AdapterServicB asb1 = new AdapterServicB();

		asa1.runService();
		asb1.runService();
	}
}
///////
package adapterPattern;

public class AdapterServicA {
	ServiceA sa1 = new ServiceA();

	void runService() {
		sa1.runServiceA();
	}
}
///////
package adapterPattern;

public class AdapterServicB {
	ServiceB sb1 = new ServiceB();

	void runService() {
		sb1.runServiceB();
	}
}
```

#### 프록시 패턴(Proxy Pattern)

: 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴

> 실제 서비스 메서드의 반환 값에 가감하는 것을 목적으로 하지 않고 제어의 흐름을 변경하거나 다른 로직을 수행하기 위해 사용한다.

* 프록시는 대리자/대변인이라는 뜻이다. 
* 인터페이스를 사용하면서 서비스 객체가 들어갈 자리에 대리자 객체를 대신 투입해 클라이언트 쪽에서는 실제 서비스 객체를 통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리할 수도 있다.
* 대라자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
* 대리자는 실제 서비스에 대한 참조 변수를 갖는다.(합성)
* 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.
* 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.

```java
package proxyPattern;

public interface IService {
	String runSomething();
}
////
package proxyPattern;

public class Service implements IService {
	public String runSomething() {
		return "서비스 짱!!!";
	}
}
///
package proxyPattern;

public class Proxy implements IService {
	IService service1;

	public String runSomething() {
		System.out.println("호출에 대한 흐름 제어가 주목적, 반환 결과를 그대로 전달");

		service1 = new Service();
		return service1.runSomething();
	}
}
///
package proxyPattern;

public class ClientWithProxy {
	public static void main(String[] args) {
		// 프록시를 이용한 호출
		IService proxy = new Proxy();
		System.out.println(proxy.runSomething());
	}
}
```

#### 데코레이터 패턴(Decorator Pattern)

: 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴

* 데코레이션 패턴은 프록시 패턴과 다르게 반환값에 장식을 덧입힌다.
* 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
* 장식자는 실제 서비스에 대한 참조변수를 갖는다.(합성)
* 장식자는 실제 서비스와 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다.
* 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다.

```java
package decoratorPattern;

public interface IService {
	public abstract String runSomething();
}
///
package decoratorPattern;

public class Service implements IService {
	public String runSomething() {
		return "서비스 짱!!!";
	}
}
///
package decoratorPattern;

public class Decoreator implements IService {
	IService service;

	public String runSomething() {
		System.out.println("호출에 대한 장식 주목적, 클라이언트에게 반환 결과에 장식을 더하여 전달");

		service = new Service();
		return "정말" + service.runSomething(); // 더함
	}
}
///
package decoratorPattern;

public class ClientWithDecolator  {
	public static void main(String[] args) {
		IService decoreator = new Decoreator();
	 	System.out.println(decoreator.runSomething());
	}
}
```

#### 싱글턴 패턴(Singleton Pattern)

: 클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하는 패턴

* 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게 되어 오직 하나만 만들고 그것을 재사용한다.
* new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정한다.
* 유일한 단일 객체를 반환할 수 있는 정적 메서드가 필요하다.
  * 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다.
* 유일한 단일 객체를 참조할 정적 참조 변수가 필요하다.

```java
package singletonPattern;

public class Singleton {
	static Singleton singletonObject; // 정적 참조 변수

	private Singleton() {
	}; // private 생성자

	// 객체 반환 정적 메서드
	public static Singleton getInstance() {
        // 정적 참조 변수에 객체가 할당되지 않을 경우에만 new를 통해 객체를 만들고
        // 정적 참조 변수에 할당한다.
		if (singletonObject == null) {
			singletonObject = new Singleton();
		}
		return singletonObject;
	}
}
////
package singletonPattern;

public class Client {
	public static void main(String[] args) {
		// private 생성자임으로 new 할 수 없다.
		// Singleton s = new Singleton();

        // 모두 하나의 단일 객체를 참조한다.
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		Singleton s3 = Singleton.getInstance();

		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s3);

		s1 = null;
		s2 = null;
		s3 = null;
	}
}
```

#### 템플릿 메서드 패턴(Template Method Pattern)

: 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴

* 상위 클래스에 공통 로직을 수행하는 탬플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상 메서드 또는 선택적으로 오버라이딩할 수 있는 훅(Hook) 메서드를 두는 패턴을 탬플릿 메서드 패턴이라고 한다.

```java
package templateMethodPattern;

public abstract class Animal {
	// 템플릿 메서드
	public void playWithOwner() {
		System.out.println("귀염둥이 이리온...");
		play();
		runSomething();
		System.out.println("잘했어");
	}

	// 추상 메서드 -> 강제적
	abstract void play();

	// Hook(갈고리) 메서드 -> 선택적
	void runSomething() {
		System.out.println("꼬리 살랑 살랑~");
	}
}
///
package templateMethodPattern;

public class Dog extends Animal {
	@Override
	// 추상 메서드 오버라이딩
	void play() {
		System.out.println("멍! 멍!");
	}

	@Override
	// Hook(갈고리) 메서드 오버라이딩
	void runSomething() {
		System.out.println("멍! 멍!~ 꼬리 살랑 살랑~");
	}
}
///
package templateMethodPattern;

public class Driver {
	public static void main(String[] args) {
		Animal bolt = new Dog();
		Animal kitty = new Cat();

		bolt.playWithOwner();

		System.out.println();
		System.out.println();

		kitty.playWithOwner();
	}
}
```

#### 팩터리 메서드 패턴(Factory Method Pattern)

: 오버라이드된 메서드가 객체를 반환하는 패턴

* 팩터리 = 객체 / 팩터리 메서드 = 객체를 생성 반환하는 패턴

```java
package factoryMethodPattern;

public abstract class Animal {
	// 추상 팩터리 메서드
	abstract AnimalToy getToy();
}
///
package factoryMethodPattern;

// 팩터리 메서드가 생성할 객체의 상위 클래스
public abstract class AnimalToy {
	abstract void identify();
}
///
package factoryMethodPattern;

public class Dog extends Animal {
	// 추상 팩터리 메서드 오버라이딩
	@Override
	AnimalToy getToy() {
		return new DogToy();
	}
}
///
package factoryMethodPattern;

//팩터리 메서드가 생성할 객체
public class DogToy extends AnimalToy {
	public void identify() {
		System.out.println("나는 테니스공! 강아지의 친구!");
	}
}
///
package factoryMethodPattern;

public class Driver {
	public static void main(String[] args) {
		// 팩터리 메서드를 보유한 객체들 생성
		Animal bolt = new Dog();
		Animal kitty = new Cat();

		// 팩터리 메서드가 반환하는 객체들
		AnimalToy boltBall = bolt.getToy();
		AnimalToy kittyTower = kitty.getToy();

		// 팩터리 메서드가 반환한 객체들을 사용
		boltBall.identify();
		kittyTower.identify();
	}
}
```

#### 전략 패턴(Strategy Pattern)

: 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴

* 전략 메서드를 가진 전략 객체
* 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
* 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제 3자, 전략 객체의 공급자)

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/c31f270f-9a24-4d0d-813d-cec326c977c4)

```java
///전략 인터페이스
package strategyPattern;

public interface Strategy {
	public abstract void runStrategy();
}
/// 전략 1
package strategyPattern;

public class StrategyGun implements Strategy {
	@Override
	public void runStrategy() {
		System.out.println("탕, 타당, 타다당");
	}
}
/// 전략 2
package strategyPattern;

public class StrategySword implements Strategy {
	@Override
	public void runStrategy() {
		System.out.println("챙.. 채쟁챙 챙챙");
	}
}
/// 전략 3
package strategyPattern;

public class StrategyBow implements Strategy {
	@Override
	public void runStrategy() {
		System.out.println("슝.. 쐐액.. 쇅, 최종 병기");
	}
}
/// 전략을 사용할 컨텍스트
package strategyPattern;

public class Soldier {
	void runContext(Strategy strategy) {
		System.out.println("전투 시작");
		strategy.runStrategy();
		System.out.println("전투 종료");
	}
}
/// 무기(전략)를 조달(생성)해서 군인(컨텍스트)에게 지급(주입)해 줄 보급장교(클라이언트, 제 3자)를 구현
package strategyPattern;

public class Client {
	public static void main(String[] args) {
		Strategy strategy = null;
		Soldier rambo = new Soldier();

		// 총을 람보에게 전달해서 전투를 수행하게 한다.
		strategy = new StrategyGun();
		rambo.runContext(strategy);

		System.out.println();

		// 검을 람보에게 전달해서 전투를 수행하게 한다.
		strategy = new StrategySword();
		rambo.runContext(strategy);

		System.out.println();

		// 활을 람보에게 전달해서 전투를 수행하게 한다.
		strategy = new StrategyBow();
		rambo.runContext(strategy);
	}
}
```

#### 템플릿 콜백 패턴(Template Callback Pattern - 견본/회신 패턴)

: 전략을 익명 내부 클래스로 구현한 전략 패턴

* 전략 패턴의 변형으로, 스프링의 3대 프로그래밍 모델 중 하나인 DI(의존성 주입)에서 사용하는 특별한 형태의 전략 패턴이다.
* 전략을 익명 내부 클래스로 정의해서 사용한다.

```java
package templateCallbackPattern;

public interface Strategy {
	public abstract void runStrategy();
}
///
package templateCallbackPattern;

public class Client {
	public static void main(String[] args) {
		Soldier rambo = new Soldier();
		/*
		 * Strategy strategy = new StrategyGun();
		 * rambo.runContext(strategy);

		 * Strategy strategy = new IStrategy() {
		 * 
		 * @Override public void doStrategy() {
		 * System.out.println("총! 총초종총 총! 총!"); } };
		 * 
		 * rambo.runContext(strategy);
		 */
		rambo.runContext(new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println("총! 총초종총 총! 총!");
			}
		});

		System.out.println();

		rambo.runContext(new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println("칼! 카가갈 칼! 칼!");
			}
		});

		System.out.println();

		rambo.runContext(new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println("도끼! 독독..도도독 독끼!");
			}
		});
	}
}
```

```java
package templateCallbackPatternRefactoring;

public class Soldier {
	void runContext(String weaponSound) {
		System.out.println("전투 시작");
		executeWeapon(weaponSound).runStrategy();
		System.out.println("전투 종료");
	}

	private Strategy executeWeapon(final String weaponSound) {
		return new Strategy() {
			@Override
			public void runStrategy() {
				System.out.println(weaponSound);
			}
		};
	}
}
```

* 전략을 사용하는 컨텍스트, 즉 군인 내부로 들어왔다.

#### 스프링이 사랑한 다른 패턴들

프론트 컨트롤러 패턴, MVC 패턴

***

### 07장: 스프링 삼각형과 설정 정보

IoC/DI - 제어의 역전/의존성 주입

프로그래밍에서 의존성이란?

스프링 없이 의존성 주입하기 1 - 생성자를 통한 의존성 주입

스프링 없이 의존성 주입하기 2 - 속성을 통한 의존성 주입

스프링을 통한 의존성 주입 - XML 파일 사용

스프링을 통한 의존성 주입 - 스프링 설정 파일(XML)에서 속성 주입

스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입

스프링을 통한 의존성 주입 - @Resource를 통한 속성 주입

스프링을 통한 의존성 주입 - @Autowired vs. @Resource vs. 태그

AOP - Aspect? 관점? 핵심 관심사? 횡단 관심사?

일단 덤벼 보자 - 실전편

일단 덤벼 보자 - 설명편

일단 덤벼 보자 - 용어편

일단 덤벼 보자 - POJO와 XML 기반 AOP

AOP 기초 완성 310

PSA - 일관성 있는 서비스 추상화

~314p 토

***

### 부록A: 스프링 MVC를 이용한 게시판 구축

A.1 URL과 @RequestMapping 연결하기

A.2 인메모리 DB HSQL 사용하기

A.3 VO와 MyBatis를 이용한 DAO 구현

A.4 서비스(Service) 구현

A.5 목록 구현

A.6 읽기 구현

A.7 새 글 구현

A.8 수정 구현

A.9 삭제 구현

A.10 리팩터링

~361p

***

###  부록B: 자바 8 람다와 인터페이스 스펙 변화

B.1 람다가 도입된 이유

B.2 람다란 무엇인가?

B.3 함수형 인터페이스

B.4 메서드 호출 인자로 람다 사용

B.5 메서드 반환값으로 람다 사용

B.6 자바 8 API에서 제공하는 함수형 인터페이스

B.7 컬렉션 스트림에서 람다 사용

B.8 메서드 레퍼런스와 생성자 레퍼런스

B.9 인터페이스의 디폴트 메서드와 정적 메서드

B.10 정리

~389p

***

[^1]: Disign : 설계
