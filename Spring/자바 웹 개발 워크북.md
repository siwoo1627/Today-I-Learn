## 제 2장 웹 프로그래밍 기초 다지기

Header : 서버가 요청을 처리할 때 참고하라고 클라이언트에서 웹 서버에게 알려주는 정보

* 일반 헤더: 요청이나 응답 모두에 적용할 수 있는 헤더
  * Cache-Control, Transfer-Encoding 등
* 요청/응답 헤더:  요청 또는 응답 중 하나에만 적용하는 헤더
  * Accept-Charset, Referer, Host, User-Agent 등
* 엔티티 헤더: 보내거나 받는 본문 데이터를 설명하는 헤더
    *   Allow, Content-Encoding, Content-Type 등


| 프로토콜                                         | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| FTP(File Transfer Protocol)                      | 클라이언트와 서버 간에 파일을 주고받기 위해 만든 통신 규약   |
| Telnet 프로토콜                                  | 인터넷이나 LAN 상에서 문자 기반으로 원격의 컴퓨터를 제어하기 위해 만든 통신 규약, 요즘은 보안때문에 SSH(Secure Shell) 프로토콜 기반 원격 접속 프로그램을 주로 사용 |
| XMPP(Extexsible Messaging and Presence Protocol) | 인스턴스 메시지 및 사용자의 접속 상태 정보를  교환할 목적으로 만든 통신 규약이며 Google Talk가 이 프로토콜을 기반으로 통신한다. |
| SMPT(Simple Mail Transfer Protocol)              | 인터넷 상에서 메일을 보내기 위한 통신 규약, POP3(Post Office Protocol version3)는 이메일을 가져 오는데 사용하는 통신 규약이며 POP3는 이메일을 가져온 후 서버의 메일을 삭제한다. |
| IMAP(Internet Message Access Protocol)           | POP3와 달리 이메일을 가져온 뒤에 서버의 메일을 지우지 않으며 요즘처럼 여러 대의 장비에서 이메일을 조회하는 경우에 적합하다. 단, POP3에 비해 통신 트래픽이 높은 것이 단점 |
| LDAP(Lightweight Directory Access Protocol)      | 디렉터리 서비스에 등록된 자원들을 찾는 통신 규약이다.        |
| IRC(Internet Relay Chat)                         | 실시간 채팅을 위해 만든 통신 규약이다.                       |

## 제 3장 서블릿 프로그래밍

웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI(Common Gateway Interface)라고 하고, 이렇게 웹 서버에 의해 실행되며 CGI 규칙에 따라서 웹 서버와 데이터를 주고 받도록 작성된 프로그램을 CGI프로그램이라고 한다.

* CGI는 C,C++,Java 등 컴파일 언어는 기계어로 번역된 코드를 바로 실행하기 때문에 실행속도가 빠르지만 수정 시마다 다시 컴파일 및 재배포 해야한다.
* Perl, PHP,Python 등의 스크립트 방식은 실행할 때마다 소스 코드의 문법을 검증하고 해석해야 하기 때문에 실행속도는 느리지만 변경 사항이 발생하면 소스코드를 수정하고 저장만 하면 되므로 편리하다.

Servlet: 자바로 만든 CGI 언어

* 서블릿 컨테이너가 서블릿을 대신하여 CGI규칙에 따라 웹 서버와 데이터를 주고 받는다.

***

`web.xml`: 배치기술서 DD(Deployment Description) 이라고 부르며, 웹 애플리케이션 배치 정보를 담고 있는 파일이다.

* 서블릿을 만들고 DD파일에 배치정보를 등록하지 않으면 서블릿 컨테이너가 서블릿을 찾지 못한다.

GenericServlet : 하위 클래스에게 공통의 필드와 메서드를 상속해 주고자 존재한다(추상클래스)

* 서블릿 클래스가 필요로 하는 init(), destroy(), getServletConfig(), getServletInfo()를 미리 구현하여 상속해 준다.
* GenericServlet을 상속받는다면 service() 만 구현하면 된다.

> http://localhost:9999/Lesson03/calc?a=1&b=2

```java
public class CalculatorServlet extends GenericServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void service(ServletRequest request, ServletResponse response)
			throws ServletException, IOException {
		int a = Integer.parseInt( request.getParameter("a") );
		int b = Integer.parseInt( request.getParameter("b") );

		response.setContentType("text/plain");
		response.setCharacterEncoding("UTF-8");
		PrintWriter writer = response.getWriter();
		writer.println("a=" + a + "," + "b=" + b + "의 계산결과 입니다.");
		writer.println("a + b = " + (a + b));
		writer.println("a - b = " + (a - b));
		writer.println("a * b = " + (a * b));
		writer.println("a / b = " + ((float)a / (float)b));
		writer.println("a % b = " + (a % b));
    }
}
```

* `response.setContentType("text/plain");`: 클라이언트가 출력할 데이터 형식과 문자 집합을 지정, 출력할 데이터가 텍스트이고 별도의 메타 정보가 없는 순수한 텍스트임
* `response.setCharacterEncoding("UTF-8");`: 출력할 데이터의 문자 집합을 지정
* `PrintWriter writer = response.getWriter();`: 클라이언트로 출력할 수 있도록 출력 스트림 객체를 반환

## 제 4장 서블릿과 JDBC

### HttpServlet

```java
	// 생략
	PreparedStatement stmt = null; // insert이므로
	// Statement stmt = null; // select일 때

	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			DriverManager.registerDriver(new com.mysql.jdbc.Driver());
			conn = DriverManager.getConnection(
					"jdbc:mysql://localhost/studydb", //JDBC URL
					"study",	// DBMS 사용자 아이디
					"study");	// DBMS 사용자 암호
			stmt = conn.prepareStatement(
					"INSERT INTO MEMBERS(EMAIL,PWD,MNAME,CRE_DATE,MOD_DATE)"
					+ " VALUES (?,?,?,NOW(),NOW())");
			stmt.setString(1, request.getParameter("email")); // 첫번째 물음표
			stmt.setString(2, request.getParameter("password")); // 두번째 물음표
			stmt.setString(3, request.getParameter("name")); // 세번째 물음표
			stmt.executeUpdate();

			// 리다이렉트를 이용한 리프래시
			//response.sendRedirect("list");
            
			response.setContentType("text/html; charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.println("<html><head><title>회원등록결과</title></head>");
			// meta 태그를 이용한 리프래시
			out.println("<meta http-equiv='Refresh' content='1; url=list'>");
			out.println("<body>");
			out.println("<p>등록 성공입니다!</p>");
			out.println("</body></html>");
			// 리프래시 정보를 응답 헤더에 추가
			//response.addHeader("Refresh", "1;url=list");
            
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}

	}
```

* `HttpServlet`는 `GenericServlet`를 상속받으므로 service()가 아닌 doXXX()를 오버라이딩한다.
* doXXX()는 클라이언트 요청 방식에 따라 GET, POST, PUT 등으로 오버라이딩한다.

* 입력 매개변수의 번호는 1부터 시작한다.
* `response.addHeader("Refresh", "1;url=list");`: 1초 후 list로 이동한다.
* `response.sendRedirect("list");` 응답 결과를 출력하지 않고 이동한다.

| 비교 항목            | Statement                                                    | PreparedStatemen                                             |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 실행 속도            | 질의할 때마다 SQL 문을 컴파일한다.                           | SQL문을 미리 준비하여 컴파일해 둔다. 입력 매개변수 값만 추가하여 서버에 전송한다. 특히 여러 번 반복하여 질의하는 경우, 실행속도가 빠름 |
| 바이너리 데이터 전송 | 불가능                                                       | 가능                                                         |
| 프로그래밍 편의성    | SQL문 안에 입력 매개변수 값이 있어서 SQL 문이 복잡하고 매개변수가 여러 개인 경우 코드 관리가 힘들다 | SQL문과 입력 매개변수가 분리되어 있어 코드 작성이 편하다.    |

***

```java
@SuppressWarnings("serial")
/* 애노테이션을 이용하여 서블릿 배치 정보 설정
 * - 서블릿 초기화 파라미터도 애노테이션으로 처리 
 *
@WebServlet(
  urlPatterns={"/member/update"},
  initParams={
	  @WebInitParam(name="driver",value="com.mysql.jdbc.Driver"),
	  @WebInitParam(name="url",value="jdbc:mysql://localhost/studydb"),
	  @WebInitParam(name="username",value="study"),
	  @WebInitParam(name="password",value="study")
  }
)
*/
public class MemberUpdateServlet extends HttpServlet {
	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;
		try {
			Class.forName(this.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						this.getInitParameter("url"),
						this.getInitParameter("username"),
						this.getInitParameter("password")); 
			stmt = conn.createStatement();
			rs = stmt.executeQuery(
				"SELECT MNO,EMAIL,MNAME,CRE_DATE FROM MEMBERS" + 
				" WHERE MNO=" + request.getParameter("no"));	
			rs.next();
			
			response.setContentType("text/html; charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.println("<html><head><title>회원정보</title></head>");
			out.println("<body><h1>회원정보</h1>");
			out.println("<form action='update' method='post'>");
			out.println("번호: <input type='text' name='no' value='" +
				request.getParameter("no") + "' readonly><br>");
			out.println("이름: <input type='text' name='name'" +
				" value='" + rs.getString("MNAME")  + "'><br>");
			out.println("이메일: <input type='text' name='email'" +
				" value='" + rs.getString("EMAIL")  + "'><br>");
			out.println("가입일: " + rs.getDate("CRE_DATE") + "<br>");
			out.println("<input type='submit' value='저장'>");
			out.println("<input type='button' value='취소'" + 
				" onclick='location.href=\"list\"'>");
			out.println("</form>");
			out.println("</body></html>");
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch(Exception e) {}
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}
	}
	
	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		Connection conn = null;
		PreparedStatement stmt = null;
		try {
			Class.forName(this.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						this.getInitParameter("url"),
						this.getInitParameter("username"),
						this.getInitParameter("password")); 
			stmt = conn.prepareStatement(
					"UPDATE MEMBERS SET EMAIL=?,MNAME=?,MOD_DATE=now()"
					+ " WHERE MNO=?");
			stmt.setString(1, request.getParameter("email"));
			stmt.setString(2, request.getParameter("name"));
			stmt.setInt(3, Integer.parseInt(request.getParameter("no")));
			stmt.executeUpdate();
			
			response.sendRedirect("list");
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}
	}
}
```

* ```java
  @WebServlet(
    urlPatterns={"/member/update"},
    initParams={
  	  @WebInitParam(name="driver",value="com.mysql.jdbc.Driver"),
  	  @WebInitParam(name="url",value="jdbc:mysql://localhost/studydb"),
  	  @WebInitParam(name="username",value="study"),
  	  @WebInitParam(name="password",value="study")
    }
  )
  ```

  : 웹 애노테이션으로 DB연결 설정

  `Class.forName(this.getInitParameter("driver"));` driver에 해당하는 `com.mysql.jdbc.Driver` 가져옴

* `conn = DriverManager.getConnection(`: Driver로 가져온 db연결하여 사용



### 컨텍스트 초기화 매개변수

: 각 서블릿마다 JDBC 드라이버와 데이터베이스 연결에 대한 정보를 설정하지 않고 같은 웹 애플리케이션에 소속된 서블릿들이 공유하는 서블릿컨텍스트를 사용한다.

> web.xml

```xml
<!-- 컨텍스트 초기화 파라미터 -->
	<context-param>
		<param-name>driver</param-name>
		<param-value>com.mysql.jdbc.Driver</param-value>
	</context-param>
	<context-param>
		<param-name>url</param-name>
		<param-value>jdbc:mysql://localhost/studydb</param-value>
	</context-param>
	<context-param>
		<param-name>username</param-name>
		<param-value>study</param-value>
	</context-param>
	<context-param>
		<param-name>password</param-name>
		<param-value>study</param-value>
	</context-param>
```

```java
// 생략
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password")); 
			stmt = conn.createStatement();
// 생략
```

### 필터

: 서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술

```java
package spms.filters;

// 생략

@WebFilter(
	urlPatterns="/*",
	initParams={
		@WebInitParam(name="encoding",value="UTF-8")
	})
public class CharacterEncodingFilter implements Filter{
	FilterConfig config;
	
	@Override
	public void init(FilterConfig config) throws ServletException {
		this.config = config;
	}
	
	@Override
	public void doFilter(
			ServletRequest request, ServletResponse response,
			FilterChain nextFilter) throws IOException, ServletException {
		request.setCharacterEncoding(config.getInitParameter("encoding"));
        /* 서블릿이 실행되기 전에 해야 할 작업 */
        
        // 다음 필터를 호출, 더이상 필터가 없다면 서블릿의 service()가 호출됨
		nextFilter.doFilter(request, response);
        
        /* 서블릿이 실행한 후, 클라이언트에게 응답하기 전에 해야할 작업 */
	}

	@Override
	public void destroy() {}
}

```

> web.xml

```xml
	<!-- 필터 선언 --> 
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>spms.filters.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
	
	<!-- 필터 URL 매핑 -->
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
```

* `<url-pattern>/*</url-pattern>`: 모든 요청에 대해 필터 적용

## 제 5장 MVC 아키텍처

**JSP 프리컴파일**: 서버에 배치할 때 JSP 파일에 대해 자바 서블릿 클래스를 미리 생성하기도 한다. JSP 실행 요청이 들어 왔을 때, 곧바로 서블릿을 호출할 수 있어, JSP를 실행할 때마다 JSP 파일이 변경되었는지, JSP 파일에 대해 서블릿 파일이 있는지 매번 검사할 필요가 없어 컴파일하는 과정이 없으므로 실행속도가 빠르다.

단, JSP를 편집하면 서버를 다시 시작해야한다.

#### JSP 전용 태그 - 지시자

`<%@ 지시자 속성="값" 속성="값" ... %>`

* page: JSP페이지와 관련된 속성을 정의할 때 사용

  * ```jsp
    <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
    <!-- pageEncoding: 출력할 데이터 타입을 지정 -->
    ```

* taglib

* include

#### JSP 전용 태그 - 스크립트릿

`<@ 자바 코드 @>`

#### JSP 내장 객체

: 스트립트릿이나 표현식을 작성할 때 별도의 선언 없이 사용가능한 자바 객체

* request, response, pageContext, session, application, config, out, page, exception

#### JSP 전용 태그 - 선언문

`<%! 멤버 변수 및 메서드 선언 %>`

#### JSP 전용 태그 - 표현식

`<%= 결과를 반환하는 자바 표현식 %>`

```jsp
<input type="text" name="v1" size="4" value="<%=v1%>"> 
<option value="+" <%=selected[0]%>>+</option>
```

### 서블릿에서 뷰 분리하기

서블릿(Model+Controller) -> JSP(View)

#### 값 객체(VO) = 데이터 수송 객체(DTO)

: 데이터베이스에서 가져온 정보를 JSP 페이지에 전달할 목적으로 정보를 담은 객체

#### 회원 목록

```java
// UI 출력 코드를 제거하고, UI 생성 및 출력을 JSP에게 위임한다.
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;

		try {
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password")); 
			stmt = conn.createStatement();
			rs = stmt.executeQuery(
					"SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
					" FROM MEMBERS" +
					" ORDER BY MNO ASC");
			
			response.setContentType("text/html; charset=UTF-8");
			ArrayList<Member> members = new ArrayList<Member>();
			
			// 데이터베이스에서 회원 정보를 가져와 Member에 담는다.
			// 그리고 Member객체를 ArrayList에 추가한다.
			while(rs.next()) {
				members.add(new Member()
							.setNo(rs.getInt("MNO"))
							.setName(rs.getString("MNAME"))
							.setEmail(rs.getString("EMAIL"))
							.setCreatedDate(rs.getDate("CRE_DATE"))	);
			}
			
			// request에 회원 목록 데이터 보관한다.
			request.setAttribute("members", members);
			
			// JSP로 출력을 위임한다!!
			RequestDispatcher rd = request.getRequestDispatcher(
					"/member/MemberList.jsp");
			rd.include(request, response);
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch(Exception e) {}
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}

	}
}
```

```jsp
<%@page import="spms.vo.Member"%>
<%@page import="java.util.ArrayList"%>
<%@ page 
	language="java" 
	contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>회원 목록</title>
</head>
<body>
<h1>회원목록</h1>
<p><a href='add'>신규 회원</a></p>
<%
ArrayList<Member> members = (ArrayList<Member>)request.getAttribute(
								"members");
for(Member member : members) {
%>
<%=member.getNo()%>,
<a href='update?no=<%=member.getNo()%>'><%=member.getName()%></a>,
<%=member.getEmail()%>,
<%=member.getCreatedDate()%>
<a href='delete?no=<%=member.getNo()%>'>[삭제]</a><br>
<%} %>
</body>
</html>
```

**포워드(forward)**: 제어권을 넘기고 안돌아옴, ex) 예외 발생

```java
// 생략
	} catch (Exception e) {
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
			rd.forward(request, response);
// 생략
```

```jsp
<%@ page 
	language="java" 
	contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>시스템 오류!</title>
</head>
<body>
<p>요청을 처리하는 중에 문제가 발생하였습니다. 잠시 후에 다시 요청하시기 바랍니다.
만약 계속해서 이 문제가 발생된다면 시스템 운영팀(사내번호: 8282)에 연락하기 바랍니다.</p>
</body>
</html>
```

**인클루드(include)**: 제어권을 넘기고 그 서블릿이 작업이 끝나면 돌아옴, ex) Header, Tail

```jsp
<jsp:include page="/Header.jsp"/>
<!-- 생략 -->
<jsp:include page="/Tail.jsp"/>
```

### 데이터 보관소

데이터를 공유하기 위한 서블릿 기술

```java
보관소 객체.setAttribute(키, 값); // 값 저장
보관소 객체.getAttribute(키); // 값 저장
```

#### ServletContext

: 웹 애플리케이션이 시작될 때 생성되어 웹 애플리케이션이 종료될 때까지 유지된다. 

* application 변수를 통해 참조

```java
@SuppressWarnings("serial")
public class AppInitServlet extends HttpServlet {

	@Override
	public void init(ServletConfig config) throws ServletException {
		System.out.println("AppInitServlet 준비…");
		super.init(config);
		try {
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			Connection conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password"));
			
			sc.setAttribute("conn", conn);
		} catch(Throwable e) {
			throw new ServletException(e);
		}
	}
	
	@Override
	public void destroy() {
		System.out.println("AppInitServlet 마무리...");
		super.destroy();
		Connection conn = 
				(Connection)this.getServletContext().getAttribute("conn"); 
		try {
			if (conn != null && conn.isClosed() == false) {
				conn.close();
			}
		} catch (Exception e) {}
		
	}
}
```

* `sc.setAttribute("conn", conn);`: 데이터베이스 커넥션 객체를 보관소에 저장해서 모든 웹 애플리케이션에서 사용가능하도록 처리

```xml
	<!-- 서블릿 선언 -->
	<servlet>
    <servlet-name>AppInitServlet</servlet-name>
    <servlet-class>spms.servlets.AppInitServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
```

* `<load-on-startup>`: 클라이언트 요청이 없더라도 웹 애플리케이션이 시작되면 자동으로 실행

#### HttpSession

: 클라이언트의 최초 요청 시 생성되어 브라우저를 닫을 때까지 유지, 보통 로그인할 때 생성하고 로그아웃하면 비운다.

* session 변수를 통해 참조

```java
@WebServlet("/auth/login")
public class LogInServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		RequestDispatcher rd = request.getRequestDispatcher(
				"/auth/LogInForm.jsp");
		rd.forward(request, response);
	}
	
	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			ServletContext sc = this.getServletContext();
			conn = (Connection) sc.getAttribute("conn");  
			stmt = conn.prepareStatement(
					"SELECT MNAME,EMAIL FROM MEMBERS"
					+ " WHERE EMAIL=? AND PWD=?");
			stmt.setString(1, request.getParameter("email"));
			stmt.setString(2, request.getParameter("password"));
			rs = stmt.executeQuery();
			if (rs.next()) {
				Member member = new Member()
						.setEmail(rs.getString("EMAIL"))
						.setName(rs.getString("MNAME"));
				HttpSession session = request.getSession();
				session.setAttribute("member", member);
				
				response.sendRedirect("../member/list");
			} else {
				RequestDispatcher rd = request.getRequestDispatcher(
						"/auth/LogInFail.jsp");
				rd.forward(request, response);
			}
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch (Exception e) {}
			try {if (stmt != null) stmt.close();} catch (Exception e) {}
		}
	}
}
```

* 로그인 성공일 경우 Member 객체를 HttpSession에 보관한다.

```jsp
<%@page import="spms.vo.Member"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
Member member = (Member)session.getAttribute("member");
%>
<div style="background-color:#00008b;color:#ffffff;height:20px;padding: 5px;">
SPMS(Simple Project Management System)
<span style="float:right;">
<%=member.getName()%>
<a style="color:white;" 
  href="<%=request.getContextPath()%>/auth/logout">로그아웃</a>
</span>
</div>
```

* JSP 내장 객체 session을 사용하여 member라는 키로 저장된 값을 꺼낸다.

```java
@WebServlet("/auth/logout")
public class LogOutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		session.invalidate();
		
		response.sendRedirect("login");
	}
}
```

* `session.invalidate();`: 세션 객체 무효화한다.

#### ServletRequest

: 클라이언트의 요청이 들어올 때 생성되어, 클라이언트에게 응답할 때까지 유지, 보통 포워딩이나 인클루딩하는 서블릿들 사이에서 값을 공유한다.

* request 변수를 통해 참조

```java
// 생략
	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		RequestDispatcher rd = request.getRequestDispatcher(
				"/auth/LogInForm.jsp");
		rd.forward(request, response);
	}
// 생략
```

#### JspContext의 활용

: JSP 페이지를 실행하는 동안만 유지

* pageContext 변수를 통해 참조

```jsp
<body>
<jsp:include page="/Header.jsp"/>
<h1>회원목록</h1>
```

* 태그 핸들러를 사용하기 위해 필요하다.

### JSP 액션 태그

`<jsp:useBean>`: 보관소에서 자바 인스턴스를 꺼내거나, 자바 인스턴스를 새로 만들어 보관소에 저장하는 코드를 생성한다. 자바 인스턴스를 자바빈(JavaBean)이라고 한다.

```jsp
<jsp:useBean id="members"
  scope="request"
  class="java.util.ArrayList" 
  type="java.util.ArrayList<spms.vo.Member>"/>
<jsp:useBean id="member"
  scope="session"
  class="spms.vo.Member"/>
```

* scope: 보관소를 의미, request일 경우 servletRequest 보관소
* type: 참조변수를 선언할 타입의 이름

`<jsp:setProperty>`: 자바 빈의 프로퍼티 값을 설정, 자바 객체의 setter 메서드를 호출하는 코드 생성

`<jsp:getProperty>`: 자바 빈의 프로퍼티 값을 꺼냄, 자바 객체의 getter 메서드를 호출하는 코드 생성

`<jsp:param>`: `<jsp:include>`,`<jsp:forward>`의 자식 태그로 사용할 수 있음, ServletRequest  객체에 매개변수를 추가하는 코드를 생성

### EL(Expression Language)

`${객체이름.프로퍼티}` 또는 `${객체이름["프로퍼티"]}`

> `${member.no}`, `${member["no"]}`

* EL을 사용할 경우 `<jsp:useBean>` 액션 태그를 사용할 필요도 없으며 `<%=member.getNo()%>` 보다 간결하다.

* EL안에서 값, 연산 모두 가능

```jsp
${"테스트"} // 테스트
${1} // 1
${1+1} // 2
번호: <input type='text' name='no' value='${member.no}' readonly><br>
이름: <input type='text' name='name' value='${member.name}'><br>
이메일: <input type='text' name='email' value='${member.email}'><br>
가입일: ${member.createdDate}<br>
```

### JSTL(Java Standard Tab Library)

태그 라이브러리 선언: `<%@ tablib uri="사용할 태그의 라이브러리 URI" prefix="접두사" %>`

| 태그 라이브러리 | 접두사 | 네임스페이스의 URI 식별자               |
| --------------- | ------ | --------------------------------------- |
| Core            | c      | http://java.sun.com/jsp/jstl/core       |
| XML             | x      | http://java.sun.com/jsp/jstl/xml        |
| \|18N           | fmt    | http://java.sun.com/jsp/jstl/fmt        |
| Database        | sql    | http://java.sun.com/jsp/jstl/sql        |
| Functions       | fn     | http://java. sun.com/jsp/jstl/functions |

* `<c:out value="출력할 값">기본값</c:out>`

* `<c:set value="값" target="${객체}" property="propertyName" scope="request" var="변수 명" />`
* `<c:if>`: 조건
* `<c:choose>`: switch case문
* `<c:forEach>`: 반복
* `<c:forTokens>`: 문자열을 특정 구분자로 분리하여 반복문을 돌림
* `<c:url>`: url 생성

나머진 JSP.md 파일에서 찾거나 구글링

```jsp
<!-- <%@page import="spms.vo.Member"%> -->
<!-- <%@page import="java.util.ArrayList"%> -->

<%@ page 
  language="java" 
  contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>      
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>회원 목록</title>
</head>
<body>
<jsp:include page="/Header.jsp"/>
<h1>회원목록</h1>
<p><a href='add.do'>신규 회원</a></p>
<!-- <jsp:useBean id="members"
  scope="request"
  class="java.util.ArrayList" 
  type="java.util.ArrayList<spms.vo.Member>"/> -->
<c:forEach var="member" items="${members}"> 
${member.no},
<a href='update.do?no=${member.no}'>${member.name}</a>,
${member.email},
${member.createdDate}
<a href='delete.do?no=${member.no}'>[삭제]</a><br>
</c:forEach>
<jsp:include page="/Tail.jsp"/>
</body>
</html>
```

### DAO(Data Acess Object) 분리

: 데이터베이스와 연동하여 데이터를 처리하는 부분을 분리

> MemberDAO.java

```java
// 생략
public class MemberDao {
  Connection connection;

  public void setConnection(Connection connection) {
    this.connection = connection;
  }

  public List<Member> selectList() throws Exception {
    Statement stmt = null;
    ResultSet rs = null;

    try {
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
    }
  }
}
// 생략
```

* selectList() 리턴 타입이 `List` 이다.

* ```java
    Connection connection;
    
    public void setConnection(Connection connection) {
      this.connection = connection;
    }
  ```

  * 작업에 필요한 객체를 외부로부터 주입 받는 것을 '의존성 주입(DI)' 또는 '역제여(IoC, Invension of Control)'이라고 부른다.

> MemberListServlet.java

```java
// MemberDao 사용  
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			ServletContext sc = this.getServletContext();
			Connection conn = (Connection) sc.getAttribute("conn"); 
			
			MemberDao memberDao = new MemberDao();
			memberDao.setConnection(conn);
			
			request.setAttribute("members", memberDao.selectList());
			
			response.setContentType("text/html; charset=UTF-8");
			RequestDispatcher rd = request.getRequestDispatcher(
					"/member/MemberList.jsp");
			rd.include(request, response);
			
		} catch (Exception e) {
			e.printStackTrace();
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
			rd.forward(request, response);
		}
	}
}
```

* MemberListServlet 클래스에는 데이터베이스와 관련된 코드가 존재하지 않고 MemberDAO로 이관됨

### 리스너

서블릿 컨테이너는 웹 애플리케이션의 상태를 모니터링 할 수 있도록 웹 애플리케이션 시작에서 종료까지 주요한 사건에 대해 알림 기능을 제공한다. 이런 알림 기능을 이용하고 싶다면, 규칙에 따라 객체를 만들어 DD파일(web.xml)에 등록하면 되고 이렇게 사건이 발생했을 때 알림을 받는 객체릴 '리스너(Listener)'라고 부른다.

#### ServletContextListener

: 웹 애플리케이션이 시작하거나 종료할 때 이벤트

* 웹 애플리케이션이 시작, 종료할 때 DAO 객체를 준비하여 ServletContext에 저장한다.

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  Connection conn;
  
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      Class.forName(sc.getInitParameter("driver"));
      conn = DriverManager.getConnection(
          sc.getInitParameter("url"),
          sc.getInitParameter("username"),
          sc.getInitParameter("password"));

      MemberDao memberDao = new MemberDao();
      memberDao.setConnection(conn);

      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    try {
      conn.close();
    } catch (Exception e) {}
  }
}
```

* `contextInitialized`: 웹 애플리케이션 시작

* `contextDestroyed`: 종료

* `Connection conn = (Connection) sc.getAttribute("conn"); ` -> 제거

* ```java
  ServletContext sc = this.getServletContext();
  // Connection conn = (Connection) sc.getAttribute("conn"); 
  
  // MemberDao memberDao = new MemberDao();
  // memberDao.setConnection(conn);
  MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");
  ```

### DB 커넥션풀

: DB 커넥션 객체를 여러 개 생성하여 pool에 담에 놓고 필요할 때 꺼내 쓰는 방식

* 어떤 요청을 처리하다가 예외가 발생하여 롤백한다면, 다른요청에대해 작업한 내역까지 롤백되는 문제가 발생하므로 각 요청에 대해 별도의 커넥션 객체를 사용하기 때문에 다른 작업에 영향을 주지 않는다.
* 사용한 DB커넥션 객체는 버리지 않고 풀에 보관 후 사용하므로 가비지가 생성되지 않고 속도도 빨라진다.

```java
public class DBConnectionPool {
  String url;
  String username;
  String password;
  ArrayList<Connection> connList = new ArrayList<Connection>();
  
  // 생성자는 DB 커텍션 생성에 필요한 값을 매개변수로 받는다.
  public DBConnectionPool(String driver, String url, 
      String username, String password) throws Exception {
    this.url = url;
    this.username = username;
    this.password = password;
    
    Class.forName(driver);
  }
  
  public Connection getConnection() throws Exception {
    if (connList.size() > 0) {
      Connection conn = connList.remove(0); 
      if (conn.isValid(10)) {
        // 유효성 체크 후 반환
        return conn;
      }
    }
    return DriverManager.getConnection(url, username, password); 
    // ArrayList에 보관된 객체가 없다면, DriverManager를 통해 새로만들어 반환
  }
    
  // 커넥션 객체를 쓰고 난 다음에는 이 메서드를 호출하여 커텍션 풀에 반환하여 다시 사용
  public void returnConnection(Connection conn) throws Exception {
    connList.add(conn);
  }
  
  // 웹 애플리케이션이 종료하기 전에 이 메서드를 호출하여 데이터베이스와 연결된 것을 모두 끊어야함
  public void closeAll() {
    for(Connection conn : connList) {
      try{conn.close();} catch (Exception e) {}
    }
  }
}
```

> MemberDAO.java

```java
// 생략
public class MemberDao {
  // Connection connection;

  // public void setConnection(Connection connection) {
  //  this.connection = connection;
  // }
    
  DBConnectionPool connPool;

  public void setDbConnectionPool(DBConnectionPool connPool) {
    this.connPool = connPool;
  }

  public List<Member> selectList() throws Exception {
    Statement stmt = null;
    ResultSet rs = null;

    try {
      connection = connPool.getConnection(); 
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
      if (connection != null) connPool.returnConnection(connection);
    }
  }
}
// 생략
```

* `DBConnectionPool connPool;`: 추가
* `connection = connPool.getConnection(); `: 추가

* `if (connection != null) connPool.returnConnection(connection);`: 추가

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
//  Connection conn;
  DBConnectionPool connPool;
    
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      //Class.forName(sc.getInitParameter("driver"));
      //conn = DriverManager.getConnection(
      //    sc.getInitParameter("url"),
      //    sc.getInitParameter("username"),
      //    sc.getInitParameter("password"));

      connPool = new DBConnectionPool(
          sc.getInitParameter("driver"),
          sc.getInitParameter("url"),
          sc.getInitParameter("username"),
          sc.getInitParameter("password"));
        
        
      MemberDao memberDao = new MemberDao();
      //memberDao.setConnection(conn);
      memberDao.setDbConnectionPool(connPool);
      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    //try {
    //  conn.close();
    //} catch (Exception e) {}
    connPool.closeAll();
  }
}
```

* `memberDao.setDbConnectionPool(connPool);`: MemberDAO 객체를 생성할 때 커넥션풀 객체를 주입한다.

### DataSource와 JNDI

#### DataSource

: DriverManager를 통해 DB커넥션을 얻는 것보다 좋은 기능을 제공한다.

* 서버에서 관리하기 때문에 데이터베으산 JDBC 드라이버가 변경되더라도 애플리케이션을 바꿀 필요가 없다.
* Connection과 Statement 객체를 풀링할 수 있으며, 분산 트랜젝션을 다룰 수 있다.

> ContextLoaderListener.java

```java
// Apache DBCP 적용

@WebListener
public class ContextLoaderListener implements ServletContextListener {
  BasicDataSource ds;
  
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      ds = new BasicDataSource();
      ds.setDriverClassName(sc.getInitParameter("driver"));
      ds.setUrl(sc.getInitParameter("url"));
      ds.setUsername(sc.getInitParameter("username"));
      ds.setPassword(sc.getInitParameter("password"));
      
      MemberDao memberDao = new MemberDao();
      memberDao.setDataSource(ds);
      
      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    try { if (ds != null) ds.close(); } catch (SQLException e) {}
  }
}
```

* `BasicDataSource ds;`: 아파치 DBCP 라이브러리에서 DataSource 인터페이스를 구현한 BasicDataSource 클래스의 인스턴스 변수를 선언
* `ds = new BasicDataSource();`: BasicDataSource 객체를 생성
* `memberDao.setDataSource(ds);`: MemberDAO에 주입

>MemberDao.java

```java
// 생략
public class MemberDao {    
//  DBConnectionPool connPool;
  DataSource ds;
    
//  public void setDbConnectionPool(DBConnectionPool connPool) {
//    this.connPool = connPool;
//  }

  public void setDataSource(DataSource ds) {
    this.ds = ds;
  }
    
  public List<Member> selectList() throws Exception {
    Connection connection = null;
    Statement stmt = null;
    ResultSet rs = null;

    try {
//      connection = connPool.getConnection(); 
      connection = ds.getConnection();
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
      //if (connection != null) connPool.returnConnection(connection);
      try {if (connection != null) connection.close();} catch(Exception e) {}
    }
  }
}
// 생략
```

#### 서버에서 DataSource 사용

> context.xml

```xml
	<Resource name="jdbc/studydb" auth="Container" type="javax.sql.DataSource"
	    maxActive="10" maxIdle="3" maxWait="10000" 
	    username="study"
	    password="study" 
	    driverClassName="com.mysql.jdbc.Driver"
	    url="jdbc:mysql://localhost/studydb" 
	    closeMethod="close"/>
```

* `name="jdbc/studydb"`: JNDI이름, java:comp/env 디렉터리에서 찾을 수 있다.

> web.xml

```xml
<resource-ref>
	<res-ref-name>jdbc/studydb</res-ref-name>
	<res-type>javax.sql.DataSource</res-type>
	<res-auth>Contrainer</res-auth>
</resource-ref>
```

* `<res-ref-name>JNDI 이름</res-ref-name>`
* `<res-type>리턴될 자원의 클래스 이름(패키지명 포함)</res-type>`
* `<res-auth>자원 관리의 주체</res-auth>`: Contrainer는 서버에서 관리한다는 의미

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
//  BasicDataSource ds;
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      InitialContext initialContext = new InitialContext();
      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
      MemberDao memberDao = new MemberDao();
      memberDao.setDataSource(ds);
      
      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* `InitialContext initialContext = new InitialContext();`: BasicDataSource를 직접 사용하지 않으므로 톰캣에서 자원을 찾기 위해 InitialContext 객체를 생성
* `DataSource ds = (DataSource)initialContext.lookup("java:comp/env/jdbc/studydb");`
  * JNDI 이름으로 등록되어 있는 서버 자원을 찾기 위해 lookup 메서드 이용

## 제 6장 미니 MVC 프레임워크 만들기

기존의 1개의 컨트롤러에서 프런트 컨트롤러와 페이지 컨트롤러로 분리

프런트 컨트롤러: VO 객체의 준비, 뷰 컴포넌트로 위임, 오류 처리 등과 같은 공동작업

페이지 컨트롤러: 이름 그대로 요청한 페이지만을 위한 작업을 수행

> DispatcherServlet.java

```java
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      String pageControllerPath = null;
      
      if ("/member/list.do".equals(servletPath)) {
        pageControllerPath = "/member/list";
      } else if ("/member/add.do".equals(servletPath)) {
        pageControllerPath = "/member/add";
        if (request.getParameter("email") != null) {
          request.setAttribute("member", new Member()
            .setEmail(request.getParameter("email"))
            .setPassword(request.getParameter("password"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/update.do".equals(servletPath)) {
        pageControllerPath = "/member/update";
        if (request.getParameter("email") != null) {
          request.setAttribute("member", new Member()
            .setNo(Integer.parseInt(request.getParameter("no")))
            .setEmail(request.getParameter("email"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/delete.do".equals(servletPath)) {
        pageControllerPath = "/member/delete";
      } else if ("/auth/login.do".equals(servletPath)) {
        pageControllerPath = "/auth/login";
      } else if ("/auth/logout.do".equals(servletPath)) {
        pageControllerPath = "/auth/logout";
      }
      
      RequestDispatcher rd = request.getRequestDispatcher(pageControllerPath);
      rd.include(request, response);
      
      String viewUrl = (String) request.getAttribute("viewUrl");
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
        
      } else {
        rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
}
```

> MemberListServlet.java

```java
// 프런트 컨트롤러 적용  
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;

  @Override
  public void doGet(
      HttpServletRequest request, HttpServletResponse response)
          throws ServletException, IOException {
    try {
      ServletContext sc = this.getServletContext();
      MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");

      request.setAttribute("members", memberDao.selectList());

//	request.setAttribute("members", memberDao.selectList());
			
//	response.setContentType("text/html; charset=UTF-8");
//	RequestDispatcher rd = request.getRequestDispatcher(
//			"/member/MemberList.jsp");
//	rd.include(request, response);
        
      request.setAttribute("viewUrl", "/member/MemberList.jsp");
    } catch (Exception e) {
      throw new ServletException(e);
//	e.printStackTrace();
//	request.setAttribute("error", e);
//	RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
//	rd.forward(request, response);
    }
  }
}
```

> MemberAddServlet.java

```java
// 프런트 컨트롤러 적용  
@WebServlet("/member/add")
public class MemberAddServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;

  @Override
  protected void doGet(
      HttpServletRequest request, HttpServletResponse response)
          throws ServletException, IOException {
    request.setAttribute("viewUrl", "/member/MemberForm.jsp");
  }

  @Override
  protected void doPost(
      HttpServletRequest request, HttpServletResponse response)
          throws ServletException, IOException {
    try {
      ServletContext sc = this.getServletContext();
      MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");
      
      Member member = (Member)request.getAttribute("member");
      memberDao.insert(member);
      
      request.setAttribute("viewUrl", "redirect:list.do");

    } catch (Exception e) {
      throw new ServletException(e);
    }
  }
}
```

* *.do 요청 -> DispatcherServlet(프론트 컨트롤러) -> MemberListServlet(페이지 컨트롤러), MemberAddServlet(페이지 컨트롤러)

### 페이지 컨트롤러의 진화

: 페이지 컨트롤러를 servlet에서 일반 클래스로 전환

> Controller.java

```java
package spms.controls;

import java.util.Map;

public interface Controller {
  String execute(Map<String, Object> model) throws Exception;
}
```

* `execute()`: 페이지 컨트롤러에게 일을 시키기 위한 메서드, 프런트 컨트롤러가 excute() 를 호출하려면 Map 객체를 매개변수로 넘겨줘야 한다.

> MemberListController.java

```java
public class MemberListController implements Controller {
  @Override
  public String execute(Map<String, Object> model) throws Exception {
    // Map(model) 객체에서 MemberDao를 꺼낸다.
    MemberDao memberDao = (MemberDao)model.get("memberDao");
    
    // 회원 목록 데이터를 Map 객체에 저장한다.
    model.put("members", memberDao.selectList());
    
    // 화면을 출력할 페이지의 URL을 반환한다.
    return "/member/MemberList.jsp";
  }
}
```

> DispatcherServlet.java

```java
// Controller 규칙에 따라 페이지 컨트롤러를 호출
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      ServletContext sc = this.getServletContext();
      
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
      model.put("memberDao", sc.getAttribute("memberDao"));
      model.put("session", request.getSession());
      
      Controller pageController = null;
      
      if ("/member/list.do".equals(servletPath)) {
        pageController = new MemberListController();
      } else if ("/member/add.do".equals(servletPath)) {
        pageController = new MemberAddController();
        if (request.getParameter("email") != null) {
          model.put("member", new Member()
            .setEmail(request.getParameter("email"))
            .setPassword(request.getParameter("password"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/update.do".equals(servletPath)) {
// 생략
      } else if ("/member/delete.do".equals(servletPath)) {
        pageController = new MemberDeleteController();
        model.put("no", new Integer(request.getParameter("no")));
      } else if ("/auth/login.do".equals(servletPath)) {
// 생략
      } else if ("/auth/logout.do".equals(servletPath)) {
        pageController = new LogOutController();
      }
      
      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
      
      // Map 객체에 저장된 값을 ServletRequest에 복사한다.
      for (String key : model.keySet()) {
        request.setAttribute(key, model.get(key));
      }
      
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
      } else {
        RequestDispatcher rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
}
```

* `model.put("memberDao", sc.getAttribute("memberDao"));`: ServletContext에 담긴 MemberDao 객체를 꺼내서 Map 객체에 담음
* `String viewUrl = pageController.execute(model);`: excute 반환값은 화면 출력을 수행하는 JSP의 URL
* `request.setAttribute(key, model.get(key));`: 페이지 컨트롤러의 실행이 끝난 다음, Map 객체에 보관되어 있는 데이터나 객체를 JSP가 사용할 수 있도록 ServletRequset에 복사

> MemberAddController.java

```java
public class MemberAddController implements Controller {
  @Override
  public String execute(Map<String, Object> model) throws Exception {
    if (model.get("member") == null) { // 입력폼을 요청할 때
      return "/member/MemberForm.jsp";
      
    } else { // 회원 등록을 요청할 때
      MemberDao memberDao = (MemberDao)model.get("memberDao");
      
      Member member = (Member)model.get("member");
      memberDao.insert(member);
      
      return "redirect:list.do";
    }
  }
}
```

* `if (model.get("member") == null) {`: Map 객체에 Member 인스턴스가 없을 경우



### DI를 이용한 빈 의존성 관리

데이터베이스로부터 회원 정보를 가져다줄 MemberDao와 같이 특정 작업을 수행할 때 사용하는 객체를 '의존객체'라고 한다.

* 의존 객체를 미리 생성 후 사용

```java
    MemberDao memberDao = (MemberDao)model.get("memberDao");
    model.put("members", memberDao.selectList());
    return "/member/MemberList.jsp";
```

의존 객체를 직접 생성하거나 보관소에서 꺼내는 방식으로 관리하면 결합도 증가에 따른 문제가 발생한다.

1. 의존 객체 사용과 의존 객체 변경이 발생하면 바로 영향을 받는다.
2. 데이터베이스가 바뀔 때마다 DAO를 사용하는 코드도 변경해야한다.
   * MySQL -> Oracle

#### 외부에서 주입(DI)

> MemberListController.java

```java
// 의존 객체 주입을 위해 인스턴스 변수와 셋터 메서드 추가
//- 또한 의존 객체를 꺼내는 기존 코드 변경
public class MemberListController implements Controller {
  MemberDao memberDao;
  
  public MemberListController setMemberDao(MemberDao memberDao) {
    this.memberDao = memberDao;
    return this;
  }

  @Override
  public String execute(Map<String, Object> model) throws Exception {
    model.put("members", memberDao.selectList());
    return "/member/MemberList.jsp";
  }
}
```

> ContextLoaderListener.java

```java
// 페이지 컨트롤러 객체 준비
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      InitialContext initialContext = new InitialContext();
      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
      MemberDao memberDao = new MemberDao();
      memberDao.setDataSource(ds);

//      sc.setAttribute("memberDao", memberDao);
        
      sc.setAttribute("/auth/login.do", 
          new LogInController().setMemberDao(memberDao));
      sc.setAttribute("/auth/logout.do", new LogOutController());
      sc.setAttribute("/member/list.do", 
          new MemberListController().setMemberDao(memberDao));
      sc.setAttribute("/member/add.do", 
          new MemberAddController().setMemberDao(memberDao));
      sc.setAttribute("/member/update.do", 
          new MemberUpdateController().setMemberDao(memberDao));
      sc.setAttribute("/member/delete.do", 
          new MemberDeleteController().setMemberDao(memberDao));
      
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* `sc.setAttribute("memberDao", memberDao);`: memberDao를 별도로 꺼내서 사용할 일이 없기 때문에 ServletContext에 저장하지 않는다.
* `sc.setAttribute("/auth/login.do", new LogInController().setMemberDao(memberDao));`: 페이지 컨트롤러 객체를 생성하고 나서 MemberDAO가 필요한 객체에 대해서는 셋터 메서드를 호출하여 주입한다. 이렇게 생성된 페이지 컨트롤러를 SertvletContext에 저장한다.

> DispatcherServlet.java

```java
// ServletContext에 보관된 페이지 컨트롤러를 사용
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      ServletContext sc = this.getServletContext();
      
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
//      model.put("memberDao", sc.getAttribute("memberDao"));
        model.put("session", request.getSession());
      
      Controller pageController = (Controller) sc.getAttribute(servletPath);
      
      if ("/member/add.do".equals(servletPath)) {
        if (request.getParameter("email") != null) {
          model.put("member", new Member()
            .setEmail(request.getParameter("email"))
            .setPassword(request.getParameter("password"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/update.do".equals(servletPath)) {
// 생략
      }
      
      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
      
      // Map 객체에 저장된 값을 ServletRequest에 복사한다.
      for (String key : model.keySet()) {
        request.setAttribute(key, model.get(key));
      }
      
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
      } else {
        RequestDispatcher rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
}
```

* `model.put("memberDao", sc.getAttribute("memberDao"));`: MemberDao 객체는 Map 객체에 담을 필요 없어 제거
* `Controller pageController = (Controller) sc.getAttribute(servletPath);`: 페이지 컨트롤러는 ServletContext 보관소에 저장되어 있으며 이 보관소에서 페이지 컨트롤러를 꺼낼 때는 서블릿 URL을 사용

#### 인터페이스를 활용하여 MemberDao 정의

: 각 데이터베이스에 맞춰 DAO클래스를 준비하지 않고 인터페이스를 활용하여 DAO가 갖춰야 할 규격을 정의하고, 그 규격을 준수하는 클래스라면 어떤 클래스를 상속받았는지 따지지 않고 허용한다.

> MemberDao -> MySqlMemberDao

```java
// MemberDao 인터페이스 정의 
import java.util.List;

import spms.vo.Member;

public interface MemberDao {
  List<Member> selectList() throws Exception;
  int insert(Member member) throws Exception;
  int delete(int no) throws Exception;
  Member selectOne(int no) throws Exception;
  int update(Member member) throws Exception;
  Member exist(String email, String password) throws Exception;
}
```

```java
// MemberDao 인터페이스 구현 
public class MySqlMemberDao implements MemberDao {
  // 생략
}

```

> ContextLoaderListener

```java
// MySqlMemberDao 적용
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      InitialContext initialContext = new InitialContext();
      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
//    MemberDao memberDao = new MemberDao();
      MySqlMemberDao memberDao = new MySqlMemberDao();
      memberDao.setDataSource(ds);

// 생략
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

### 리플랙션 API를 이용하여 프런트 컨트롤러 개선하기

인스턴스 자동 생성 + 메서드 자동으로 호출

> DataBinding.java

```java
public interface DataBinding {
  Object[] getDataBinders();
}
```

* 페이지 컨트롤러 중에서 클라이언트가 보낸 데이터가 필요한 경우 이 DataBinding 인터페이스를 구현한다.

>MemberAddController.java

```java
// Map 객체에 저장할 파라미터에 대한 정보 제공
// - DataBinding 인터페이스 구현
public class MemberAddController implements Controller, DataBinding {
  MemberDao memberDao;
  
  public MemberAddController setMemberDao(MemberDao memberDao) {
    this.memberDao = memberDao;
    return this;
  }
  
  public Object[] getDataBinders() {
    return new Object[]{
        "member", spms.vo.Member.class
    };
  }
  
  @Override
  public String execute(Map<String, Object> model) throws Exception {
    Member member = (Member)model.get("member");
    if (member.getEmail() == null) { // 입력폼을 요청할 때
      return "/member/MemberForm.jsp";
    } else { // 회원 등록을 요청할 때
      memberDao.insert(member);
      return "redirect:list.do";
    }
  }
}
```

* `new Object[]{"member", spms.vo.Member.class};`: 클라이언트가 보낸 매개변수 값을 Member 인스턴스에 담아서 "member"라는 이름으로 map 객체에 저장해 달라는 의미

> DispatcherServlet.java

```java
// ServletContext에 보관된 페이지 컨트롤러를 사용
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      ServletContext sc = this.getServletContext();
      
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
      model.put("session", request.getSession());
      
      Controller pageController = (Controller) sc.getAttribute(servletPath);

      if (pageController instanceof DataBinding) {
        prepareRequestData(request, model, (DataBinding)pageController);
      }

//      if ("/member/add.do".equals(servletPath)) {
//        if (request.getParameter("email") != null) {
//          model.put("member", new Member()
//            .setEmail(request.getParameter("email"))
//            .setPassword(request.getParameter("password"))
//            .setName(request.getParameter("name")));
//        }
//      } else if ("/member/update.do".equals(servletPath)) {
          // 생략
//      }
      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
      
      // Map 객체에 저장된 값을 ServletRequest에 복사한다.
      for (String key : model.keySet()) {
        request.setAttribute(key, model.get(key));
      }
      
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
      } else {
        RequestDispatcher rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
  private void prepareRequestData(HttpServletRequest request,
      HashMap<String, Object> model, DataBinding dataBinding)
      throws Exception {
    Object[] dataBinders = dataBinding.getDataBinders();
    String dataName = null;
    Class<?> dataType = null;
    Object dataObj = null;
    for (int i = 0; i < dataBinders.length; i+=2) {
      dataName = (String)dataBinders[i];
      dataType = (Class<?>) dataBinders[i+1];
      dataObj = ServletRequestDataBinder.bind(request, dataType, dataName);
      model.put(dataName, dataObj);
    }
  }
}
```

* 매개변수 값을 사용하는 페이지 컨트롤러를 추가하더라도 조건문을 삽입하는 대신 데이터 준비를 자동으로 수행하는 `prepareRequestData()`를 호출한다.
* `Object[] dataBinders = dataBinding.getDataBinders();`: 페이지 컨트롤러에게 필요한 데이터가 무엇인지 묻는다.
* `dataObj = ServletRequestDataBinder.bind(request, dataType, dataName);`: bind() 메서드는 dataName과 일치하는 요청 매개변수를 찾고 dataType을  통해 해당 클래스의 인스턴스를 생성한다. 찾은 매개변수 값을 인스턴스에 저장하며 그 인스턴스를 반환한다.

> ServletRequestDataBinder.java

```java
public class ServletRequestDataBinder {
  // DispatcherServlet에서 호출한 bind 메서드
  public static Object bind(ServletRequest request, Class<?> dataType, String dataName) throws Exception {
    // dataType이 기본타입이면 즉시 객체를 생성하여 반환
    if (isPrimitiveType(dataType)) {
      return createValueObject(dataType, request.getParameter(dataName));
    }
    
    Set<String> paramNames = request.getParameterMap().keySet();
    Object dataObject = dataType.newInstance();
    Method m = null;
    
    for (String paramName : paramNames) {
      m = findSetter(dataType, paramName);
      if (m != null) {
        m.invoke(dataObject, createValueObject(m.getParameterTypes()[0], 
            request.getParameter(paramName)));
      }
    }
    return dataObject;
  }
  // 아래 타입에 대해 기본 타입으로 간주하여 true를 반환
  private static boolean isPrimitiveType(Class<?> type) {
    if (type.getName().equals("int") || type == Integer.class ||
        type.getName().equals("long") || type == Long.class ||
        type.getName().equals("float") || type == Float.class ||
        type.getName().equals("double") || type == Double.class ||
        type.getName().equals("boolean") || type == Boolean.class ||
        type == Date.class || type == String.class) {
      return true;
    }
    return false;
  }
  // 기본 타입의 객체를 생성할 때 호출, 요청 매개변수의 값으로부터 String이나 Date 등의 기본 타입 객체를 생성한다.
  private static Object createValueObject(Class<?> type, String value) {
    if (type.getName().equals("int") || type == Integer.class) {
      return new Integer(value);
    } else if (type.getName().equals("float") || type == Float.class) {
      return new Float(value);
    } else if (type.getName().equals("double") || type == Double.class) {
      return new Double(value);
    } else if (type.getName().equals("long") || type == Long.class) {
      return new Long(value);
    } else if (type.getName().equals("boolean") || type == Boolean.class) {
      return new Boolean(value);
    } else if (type == Date.class) {
      return java.sql.Date.valueOf(value);
    } else {
      return value;
    }
  }
  // 데이터 타입(Class)과 매개변수 이름(String)을 주면 셋터 메서드를 찾아서 반환한다.
  private static Method findSetter(Class<?> type, String name) {
    Method[] methods = type.getMethods();
    
    String propName = null;
    for (Method m : methods) {
      if (!m.getName().startsWith("set")) continue;
      
      propName = m.getName().substring(3);
      if (propName.toLowerCase().equals(name.toLowerCase())) {
        return m;
      }
    }
    return null;
  }
}
```

* `ServletRequestDataBinder` 클래스는 클라이언트가 보낸 매개변수 값을 자바 객체에 담아 주는 역할을 수행한다.

### 프로퍼티를 이용한 객체 관리

DAO를 추가하는 경우에도 ContextLoaderListener 클래스에 코드 추가가 아닌, 객체를 생성하고 의존 객체를 주입하는 부분을 자동화

#### 프로퍼티 파일 작성

>/WebContent/WEB-INF/application-context.properties

```properties
#1. for ApplicationContext.
jndi.dataSource=java:comp/env/jdbc/studydb
memberDao=spms.dao.MySqlMemberDao
/auth/login.do=spms.controls.LogInController
/auth/logout.do=spms.controls.LogOutController
/member/list.do=spms.controls.MemberListController
/member/add.do=spms.controls.MemberAddController
/member/update.do=spms.controls.MemberUpdateController
/member/delete.do=spms.controls.MemberDeleteController
```

* `jndi.dataSource=java:comp/env/jdbc/studydb` = `jndi.{객체이름}={JNDI이름}`
* `memberDao=spms.dao.MySqlMemberDao` = `{객체이름}={패키지 이름을 포함한 클래스 이름}`
* `/auth/login.do=spms.controls.LogInController` = `{서블릿 URL}={패키지 이름을 포함한 클래스 이름}`

#### ApplicationContext 클래스

```java
// 프로퍼티 파일을 이용한 객체 준비
public class ApplicationContext {
  Hashtable<String,Object> objTable = new Hashtable<String,Object>();
  
  public Object getBean(String key) {
    return objTable.get(key);
  }
  
  public ApplicationContext(String propertiesPath) throws Exception {
    Properties props = new Properties();
    props.load(new FileReader(propertiesPath)); // 프로퍼티 내용을 키-값 형태로 내부 맵에 보관
    
    prepareObjects(props);
    injectDependency();
  }
  
  private void prepareObjects(Properties props) throws Exception {
    Context ctx = new InitialContext(); // JNDI 객체를 찾을 때 사용할 객체
    String key = null;
    String value = null;
    
    for (Object item : props.keySet()) {
      key = (String)item;
      value = props.getProperty(key);
      // 프로퍼티가 jndi로 시작한다면 객체를 생성하지 않고 InitialContext를 통해 얻는다
      if (key.startsWith("jndi.")) {
        objTable.put(key, ctx.lookup(value));
      } else {
// 나머지 객체는 Class.forName()을 호출하여 클래스를 로딩하고, newInstance()를 사용하여 인스턴스를 생성한다.
        objTable.put(key, Class.forName(value).newInstance());
      }
    }
  }
  
  private void injectDependency() throws Exception {
    for (String key : objTable.keySet()) {
      if (!key.startsWith("jndi.")) {
        callSetter(objTable.get(key));
      }
    }
  }

  private void callSetter(Object obj) throws Exception {
    Object dependency = null;
    for (Method m : obj.getClass().getMethods()) {
      if (m.getName().startsWith("set")) {
        dependency = findObjectByType(m.getParameterTypes()[0]);
        if (dependency != null) {
          m.invoke(obj, dependency);
        }
      }
    }
  }
  
  private Object findObjectByType(Class<?> type) {
    for (Object obj : objTable.values()) {
      if (type.isInstance(obj)) {
        return obj;
      }
    }
    return null;
  }
}
```

#### ContextLoaderListener 변경

```java
// 프로퍼티 파일 적용 : ApplicationContext 사용
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  static ApplicationContext applicationContext;

  public static ApplicationContext getApplicationContext() {
    return applicationContext;
  }
    
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      String propertiesPath = sc.getRealPath(
          sc.getInitParameter("contextConfigLocation"));
      applicationContext = new ApplicationContext(propertiesPath);
//      InitialContext initialContext = new InitialContext();
//      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
//      MySqlMemberDao memberDao = new MySqlMemberDao();
//      memberDao.setDataSource(ds);
      
//      sc.setAttribute("/auth/login.do", 
//          new LogInController().setMemberDao(memberDao));
//      sc.setAttribute("/auth/logout.do", new LogOutController());
//      sc.setAttribute("/member/list.do", 
//          new MemberListController().setMemberDao(memberDao));
//      sc.setAttribute("/member/add.do", 
//          new MemberAddController().setMemberDao(memberDao));
//      sc.setAttribute("/member/update.do", 
//          new MemberUpdateController().setMemberDao(memberDao));
//      sc.setAttribute("/member/delete.do", 
//          new MemberDeleteController().setMemberDao(memberDao));
      
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* 페이지 컨트롤러나 DAO 등을 추가할 때는 프로퍼티 파일에 그 클래스에 대한 정보를 한 줄 추가하면 자동으로 그 객체가 생성된다.

#### web.xml 파일에 프로퍼티 경로 정보 설정

```xml
  <!-- 컨텍스트 초기화 파라미터 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/application-context.properties</param-value>
  </context-param>
  <resource-ref>
      <res-ref-name>jdbc/studydb</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
  </resource-ref>
```

#### DispatcherServlet 변경

```java
// ServletContext에 보관된 페이지 컨트롤러를 사용
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
//      ServletContext sc = this.getServletContext();
      ApplicationContext ctx = ContextLoaderListener.getApplicationContext();
        
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
      model.put("session", request.getSession());
      
//      Controller pageController = (Controller) sc.getAttribute(servletPath);
      Controller pageController = (Controller) ctx.getBean(servletPath);
      if (pageController == null) {
        throw new Exception("요청한 서비스를 찾을 수 없습니다.");
      }
        
      if (pageController instanceof DataBinding) {
        prepareRequestData(request, model, (DataBinding)pageController);
      }

      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
// 생략
```

* 이전에는 페이지 컨트롤러가 ServletContext에 저장되었기 때문에 이 객체를 준비해야 했지만, ApplicationContext를 도입하면서 필요 없어져서 제거
* ContextLoaderListener의 getApplicationContext()를 호출하여 ApplicationContext 객체를 꺼냄
* 페이지 컨트롤러를 찾을 때도 ServletContext에서 찾지 않기 때문에 제거
* ApplicationContext의 getBean()메서드를 호출하여 페이지 컨트롤러를 찾고 찾지 못하면 오류 발생 시킴

### 애노테이션을 이용한 객체 관리

프로퍼티 추가 대신 애노테이션을 통해 관리

> Component.java

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {
  String value() default "";
}
```

* 애노테이션 유지 정책을 RUNTIME으로 했으므로, 실행 중에도 언제든 @Component 애노테이션을 속성값으로 참조할 수 있다.

> MySqlMemberDao.java

```java
@Component("memberDao")
public class MySqlMemberDao implements MemberDao {
  DataSource ds;
    // 생략
```

> /WebContent/WEB-INF/application-context.properties

```properties
# using Annotation
jndi.dataSource=java:comp/env/jdbc/studydb
```



#### ApplicationContext 변경

```java
// 프로퍼티 파일 및 애노테이션을 이용한 객체 준비
public class ApplicationContext {
  Hashtable<String,Object> objTable = new Hashtable<String,Object>();
  
  public Object getBean(String key) {
    return objTable.get(key);
  }
  
  public ApplicationContext(String propertiesPath) throws Exception {
    Properties props = new Properties();
    props.load(new FileReader(propertiesPath));
    
    prepareObjects(props);
    prepareAnnotationObjects(); // 추가
    injectDependency();
  }
  
  // 추가
  private void prepareAnnotationObjects() throws Exception{
    Reflections reflector = new Reflections("");
    
    Set<Class<?>> list = reflector.getTypesAnnotatedWith(Component.class);
    String key = null;
    for(Class<?> clazz : list) {
      key = clazz.getAnnotation(Component.class).value();
      objTable.put(key, clazz.newInstance());
    }
  }
// 생략
```

* 애노테이션이 붙은 클래스를 찾아서 객체를 준비하는 것이 추가됨

* `prepareAnnotationObjects()`: 자바 classpath를 뒤져서 @Component 애노테이션이 붙은 클래스를 찾아 객체를 생성하여 객체 테이블에 담는 역할을 한다.
* `Reflections`클래스는 원하는 클래스를 찾아주는 도구, 자바 classpath에 있는 모든 패키지를 검색하라는 뜻
* `getTypesAnnotatedWith()` 애노테이션이 붙은 클래스들을 찾을 수 있다.

[미니 MVC 프레임워크 게시판](https://github.com/siwoo1627/java/tree/main/Spring/%EC%9E%90%EB%B0%94%20%EC%9B%B9%20%EA%B0%9C%EB%B0%9C%20%EC%9B%8C%ED%81%AC%EB%B6%81/%EB%AF%B8%EB%8B%88%20MVC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EB%A7%8C%EB%93%A4%EA%B8%B0(%EA%B2%8C%EC%8B%9C%ED%8C%90))

## 제 7장 퍼시스턴스 프레임워크의 도입

퍼시스턴스(Persistence) : 데이터의 지속성, 즉 애플리케이션을 종료하고 다시 실행하더라도 이전에 저장한 데이터를 다시 불러올 수 있는 기술

* SQL 매퍼: SQL 문장으로 직접 DB 데이터를 다룸

  * mybatis
* 객체 관계 매퍼: 객체를 통해 간접적으로 DB 데이터를 다룸

  * 하이버네이트(Hibernate), 탑링크(TopLink)
  

### mybatis

* 개발과 유지보수가 쉽도록 소스 코드에 박혀 있는 SQL을 별도의 파일로 분리하는것
* 단순하고 반복적인 JDBC 코드를 캡슐화하여 데이터베이스 프로그래밍을 간결하게 만드는 것

### mybatis 프레임워크의 핵심 컴포넌트

| 컴포넌트                 | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| SqlSession               | 실제 SQL을 실행하는 객체, 이 객체는 SQL을 처리하기 위해 JDBC 드라이버를 사용함 |
| SqlSessionFactory        | SqlSession 객체를 생성함                                     |
| SqlSessionFactoryBuilder | mysql 설정 파일의 내용을 토대로 SqlSessionFactory를 생성함   |
| mybatis 설정 파일        | 데이터베이스 연결 정보, 트랜젝션 정보, mybatis 제어 정보 등의 설정 내용을 포함하고 있음, SqlSessionFactory를 만들 때 사용됨 |
| SQL 맵퍼 파일            | SQL문을 담고 있는 파일. SqlSession 객체가 참조함             |

SqlSession을 사용하는 DAO

> MySqlProjectDao.java

```java
// mybatis 적용
@Component("projectDao")
public class MySqlProjectDao implements ProjectDao {
  SqlSessionFactory sqlSessionFactory;

  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }

  public List<Project> selectList() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
      return sqlSession.selectList("spms.dao.ProjectDao.selectList");
    } finally {
      sqlSession.close();
    }
  }
  public int insert(Project project) throws Exception  {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
      int count = sqlSession.insert("spms.dao.ProjectDao.insert", project);
      sqlSession.commit();
      return count;
    } finally {
      sqlSession.close();
    }
  }
}
```

* `SqlSession sqlSession = sqlSessionFactory.openSession();`: SQL문을 실행할 SqlSession 객체 생성
* `return sqlSession.selectList("spms.dao.ProjectDao.selectList");`
  * spms.dao.ProjectDao.selectList 는 SQL 맵퍼의 네임스페이스 이름이고, 'selectList'는 SQL 문의 아이디이다. 즉 SQL 맵퍼 파일에서 selectList 라는 아이디를 갖는 `<select>` 태그를 가리키는 것이다.
* `sqlSession.commit();`: 임시 데이터베이스에 보관된 작업 결과를 운영 데이터베이스에 적용하라고 요청
  * rolback()은 임시 데이터베이스의 작업 결과를 운영 데이터베이스에 반영하지 않고 취소
  * `openSession(true)`메서드가 true이면 자동 커밋

기존 소스와 비교해 보면 데이터베이스와 관련된 작업은 mybatis에서 처리하기 때문에 MySqlProjectDao에서 어떤 JDBC 코드도 발견할 수 없다. 

### SqlSession 주요 메서드

| 메서드       | 설명                                                  |
| ------------ | ----------------------------------------------------- |
| selectList() | select 문을 실행, 값 객체(Value Object) 목록을 반환함 |
| selectOne()  | select 문을 실행, 하나의 값 객체를 반환함             |
| insert()     | insert 문을 실행, 반환값은 입력한 데이터 개수         |
| update()     | update 문을 실행, 반환값은 변경한 데이터 개수         |
| delete()     | delete문을 실행, 반환값은 삭제한 데이터 개수          |

### SQL 맵퍼 파일 작성

> MySqlProjectDao.xml

```xml
<mapper namespace="spms.dao.ProjectDao">
  <resultMap type="project" id="projectResultMap">
    <id column="PNO" property="no"/>
    <result column="PNAME"    property="title"/>
    <result column="CONTENT"  property="content"/>
    <result column="STA_DATE" property="startDate" javaType="java.sql.Date"/>
    <result column="END_DATE" property="endDate" javaType="java.sql.Date"/>
    <result column="STATE"    property="state"/>
    <result column="CRE_DATE" property="createdDate" javaType="java.sql.Date"/>
    <result column="TAGS"     property="tags"/>
  </resultMap>
  
  <select id="selectList" resultMap="projectResultMap">
	  select PNO, PNAME, STA_DATE, END_DATE, STATE
	  from PROJECTS
	  order by PNO desc
  </select>
  
  <insert id="insert" parameterType="project">
    insert into PROJECTS(PNAME,CONTENT,STA_DATE,END_DATE,STATE,CRE_DATE,TAGS)
    values (#{title},#{content},#{startDate},#{endDate},0,now(),#{tags})
  </insert>
</mapper>
```

* `<mapper namespace="spms.dao.ProjectDao">`: SqlSession 객체가 SQL문을 찾을 때 사용됨
* #{프로머티명} 자리에 project 객체의 프로퍼티 값이 놓인다.
  * #{title} 자리에는 project 객체의 getTitle() 반환값이 놓임
* `resultMap="spms.vo.Project"`: 결과를 담을 객체를 지정, 클래스 이름(패키지 포함)
  * 만약 mybatis 설정파일([mybatis-config.xml](#mybatis 설정 파일 준비))에 spms.vo.Project에 대한 별명에 있다면 그 별명을 사용 => `<select id="selectList" resultMap="project">`
* `<resultMap type="project" id="projectResultMap">`
  * `type`: 칼람 데이터를 저장할 클래스 이름 또는 클래스의 별명(project=spms.vo.Project)
* `<result column="END_DATE" property="endDate" javaType="java.sql.Date"/>`
  * column: 칼럼의 이름 / property: 객체의 프로퍼티 이름 / javaType: 특정 자바 객체로 반환
* `<id column="PNO" property="no"/>`: 객체의 식별자
  * select를 통해 생성된 결과 객체들을 별도의 보관소에 저장(caching)해 두고 다음 select를 생성할  때 재사용
  * 객체 풀에 보관된 객체 중에서 PNO 칼럼의 값과 일치하는 객체를 먼저 찾고 있다면 기존 객체를 사용하고 없다면 새로 생성 => mybatis의 객체 캐싱 기법

### ApplicationContext 변경

```java
// mybatis 적용에 필요한 변경 
public class ApplicationContext {
  Hashtable<String,Object> objTable = new Hashtable<String,Object>();
  
  // 생성자 제거됨 public ApplicationContext(String propertiesPath) {}

  public Object getBean(String key) {
    return objTable.get(key);
  }
  // 추가
  public void addBean(String name, Object obj) {
    objTable.put(name, obj);
  }
  
  public void prepareObjectsByAnnotation(String basePackage) 
      throws Exception{
    Reflections reflector = new Reflections(basePackage);
    
    Set<Class<?>> list = reflector.getTypesAnnotatedWith(Component.class);
    String key = null;
    for(Class<?> clazz : list) {
      key = clazz.getAnnotation(Component.class).value();
      objTable.put(key, clazz.newInstance());
    }
  }

  public void prepareObjectsByProperties(String propertiesPath) throws Exception {
    Properties props = new Properties();
    props.load(new FileReader(propertiesPath));
    
    Context ctx = new InitialContext();
    String key = null;
    String value = null;
    
    for (Object item : props.keySet()) {
      key = (String)item;
      value = props.getProperty(key);
      if (key.startsWith("jndi.")) {
        objTable.put(key, ctx.lookup(value));
      } else {
        objTable.put(key, Class.forName(value).newInstance());
      }
    }
  }
  
  public void injectDependency() throws Exception {
    for (String key : objTable.keySet()) {
      if (!key.startsWith("jndi.")) {
        callSetter(objTable.get(key));
      }
    }
  }
// 생략
}
```

### SqlSessionFactory 객체 준비

> ContextLoaderListener.java

```java
// SqlSessionFactory 객체 준비
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  static ApplicationContext applicationContext;
  
  public static ApplicationContext getApplicationContext() {
    return applicationContext;
  }
   
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      //ServletContext sc = event.getServletContext();
      
      //String propertiesPath = sc.getRealPath(
      //    sc.getInitParameter("contextConfigLocation"));
      //applicationContext = new ApplicationContext(propertiesPath);
      // ApplicationContext의 생성자에 프로퍼티 파일의 경로를 넘겨주면 프로퍼티 파일에 등록된 객체 뿐만 아니라 @Conponent 애노테이션이 붙은 클래스를 찾아서 객체를 생성했다.
       
      applicationContext = new ApplicationContext();
      
      String resource = "spms/dao/mybatis-config.xml";
      InputStream inputStream = Resources.getResourceAsStream(resource);
      SqlSessionFactory sqlSessionFactory = 
          new SqlSessionFactoryBuilder().build(inputStream);
      
      // SqlSessionFactory객체를 ApplicationContext에 등록
      applicationContext.addBean("sqlSessionFactory", sqlSessionFactory);
      
      ServletContext sc = event.getServletContext();
      String propertiesPath = sc.getRealPath(
          sc.getInitParameter("contextConfigLocation"));
      
      // 프로퍼티 파일의 내용에 따라 객체를 생성하도록 ApplicationContext에 지시
      applicationContext.prepareObjectsByProperties(propertiesPath);
      
      // @Component 애노테이션이 붙은 클래스를 찾아 객체를 생성
      applicationContext.prepareObjectsByAnnotation("");
      // ApplicationContext에서 관리하는 객체들을 조사하여 의존 객체를 주입
      applicationContext.injectDependency();
      
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }
  
  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* mybatis 설정파일 `mybatis-config.xml`은 SqlSessionFactory를 생성할 때 사용할 설계도면이다. build()의 매개변수 값으로 이 파일의 입력 스트림을 넘겨줘야 한다. 이 파일의 입력 스트림을 얻기 위해 mybatis에서 제공하는 Resources 클래스를 사용함, `getResourceAsStream()` 메서드를 통해 자바 클래스 경로에 있는 파일의 입력 스트림을 손쉽게 얻음

### db.properties 파일 작성

```properties
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost/studydb
username=study
password=study
```

### mybatis 설정 파일 준비

> mybatis-config.xml

```xml
<configuration>
	<properties resource="spms/dao/db.properties"/>
  
  <typeAliases>
    <typeAlias type="spms.vo.Project" alias="project"/>
    <typeAlias type="spms.vo.Member" alias="member"/>
  </typeAliases>
  
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="${driver}"/>
        <property name="url" value="${url}"/>
        <property name="username" value="${username}"/>
        <property name="password" value="${password}"/>
      </dataSource>
    </environment>
  </environments>
  
  <mappers>
    <mapper resource="spms/dao/MySqlProjectDao.xml"/>
  </mappers>
</configuration>
```

configuration의 주요 자식 엘리멘트

| 엘리멘트     | 용도                                                         |
| ------------ | ------------------------------------------------------------ |
| properties   | 프로퍼티 파일이 있는 경로 설정. `<property>`를 사용하여 개별 프로퍼티 정의 가능 |
| settings     | 프레임워크의 실행 환경을 설정                                |
| typeAliases  | 자바 클래스 이름(패키지 이름 포함)에 대한 별명 설정          |
| typeHandlers | 칼럼의 값을 자바 객체로, 자바 객체를 칼럼의 값으로 변환해 주는 클래스를 설정 |
| environments | 프레임워크에서 사용할 데이터베이스 정보(트랜잭션 관리자, 데이터 소스)를 설정 |
| mappers      | SQL 맵퍼 파일들이 있는 경로 설정                             |

* `<properties resource="spms/dao/db.properties"/>`: 데이터베이스 연결정보를 가지고 있는 프로퍼티 파일을 로딩한다.

* `<typeAlias type="spms.vo.Project" alias="project"/>`: 매개변수 타입이나 결과 타입을 지정할 때 긴 이름의 클래스명 대신 짧은 이름의 별명을 설정

  * SQL맵퍼에서 사용예제: `<insert id="insert" parameterType="project">`

* environment: 트랜잭션 관리 및 데이터 소스를 설정하는 태그

  * | 트랜잭션 관리 유형 | 설명                                                         |
    | ------------------ | ------------------------------------------------------------ |
    | JDBC               | 직접 JDBC의 커밋, 롤백 기능을 사용하여 mybatis 자체에서 트랜잭션을 관리 |
    | MANAGED            | 서버의 트랜잭션 관리 기능을 이용, 즉 Java EE 애플리케이션 서버나 서블릿 컨테이너 등에서 트랜젝션 관리 |

  * `<transactionManager type="JDBC"/>`: transactionManager 를 통해 관리 유형을 설정

  * | 데이터 소스 유형 | 설명                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | UNPOOLED         | DB 커넥션을 요청할 때마다 매번 커넥션 객체를 생성한다. 높은 성능을 요구하지 않는 단순한 애플리케이션에 적합하다. |
    | POOLED           | 미리 DB 커넥션 객체를 생성해 두고, 요청하면 즉시 반환한다. 데이터베이스에 연결하는 과정, 즉 연결을 초기화하고 사용자를 인증하는 과정이 없기 때문에 속도가 빠르다. |
    | JNDI             | Java EE 애플리케이션 서버나 서블릿 컨테이너에서 제공하는 데이터 소스를 사용한다. |

  * `<dataSource type="POOLED">`: mybatis 자체의 DB 커넥션풀을 사용하겠다는 의미

mybatis에서 JNDI 사용하기: 톰켓에서 직접 DB 커넥션을 관리하겠다는 의미

```xml
<configuration>
<!--  <properties resource="spms/dao/db.properties"/> -->
<!-- 생략 -->
  
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
<!--      <dataSource type="POOLED">
        <property name="driver" value="${driver}"/>
        <property name="url" value="${url}"/>
        <property name="username" value="${username}"/>
        <property name="password" value="${password}"/>
      </dataSource> -->
      <dataSource type="JNDI">
        <property name="data_source" value="java:comp/env/jdbc/studydb"/>
      </dataSource>
    </environment>
  </environments>
  
<!-- 생략 -->
</configuration>
```

### 로그 출력 켜기

: mybatis에서 실행하는 SQL문과 매개변수 값, 실행결과를 실시간으로 확인할 수 있다.

> mybatis-config.xml

```xml
  <settings>
    <setting name="logImpl" value="LOG4J"/>
  </settings>
```

* `LOG4J`: 로그 출력기 이름

로그 출력 구현체

| value 속성값          | 설명                                              |
| --------------------- | ------------------------------------------------- |
| SLF4J                 | SLF4J                                             |
| LOG4J                 | Log4j                                             |
| LOG4J2                | Log4j 2                                           |
| JDK_LOGGING           | JDK logging                                       |
| COMMONS_LOGGING       | Apache Commons Logging                            |
| STDOUT_LOGGING        | 표준 출력 장치로 출력                             |
| NO_LOGGING            | 로그 출력 기능 사용 안함                          |
| 클래스명(패키지 포함) | org.apache.ibatis.logging.Log 인터페이스의 구현체 |

> log4j.properties

```properties
# Global logging configuration
log4j.rootLogger=ERROR, stdout

# MyBatis logging configuration...
log4j.logger.spms.dao=TRACE

# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
```

* `rootLogger`: 최상위 로거

| 로그 출력 등급표 | 설명                                                       |
| ---------------- | ---------------------------------------------------------- |
| FATAL            | 애플리케이션을 중지해야 할 심각한 오류                     |
| ERROR            | 오류가 발생했지만, 애플리케이션은 계속 실행할 수 있는 상태 |
| WARN             | 잠재적인 위험을 안고 있는 상태                             |
| INFO             | 애플리케이션의 주요 실행 정보                              |
| DEBUG            | 애플리케이션의 내부 실행 상황을 추적해 볼 수 있는 상세정보 |
| TRACE            | 디버그보다 더 상세한 정보                                  |

* `stdout`: 출력 담당자
* `log4j.appender.stdout=org.apache.log4j.ConsoleAppender`: 출력 담당자 유형
  * `log4j.appender.이름=출력 담당자(패키지명 포함한 클래스명)`

| 출력 담당자 클래스                  | 설명                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| org.apache.log4j.ConsoleAppender    | System.out 또는 System.err로 로그를 출력한다. 기본은 System.out이다. 즉 표준 출력장치인 모니터로 출력한다. |
| org.apache.log4j.FileAppender       | 파일로 로그를 출력한다                                       |
| org.apache.log4j.net.SocketAppender | 원격의 로그 서버에 로그 정보를 담은 LoggingEvent 객체를 보낸다. |

* `log4j.appender.stdout.layout=org.apache.log4j.PatternLayout`: 로그의 출력 형식 정의
  * `log4j.appander.이름.layout=출력형식 클래스(패키지명을 포함한 클래스명)`

| 출력 형식 클래스               | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| org.apache.log4j.SimpleLayout  | 출력형식은 '출력 등록 - 메세지' 이다.<br />예) DEBUG - DB Connection Error! |
| org.apache.log4j.HTMLLayout    | HTML 테이블 형식으로 출력한다.                               |
| org.apache.log4j.PatternLayout | 변환 패턴의 형식에 따라 로그를 출력한다.<br />예) %-5p [%t]: %m%n<br />DEBUG [main]: Message1 |
| org.apache.log4j.xml.XMLLayout | log4j.dtd 규칙에 따라 XML을 만들어 출력한다.                 |

***

### 동적 SQL의 사용

: JSTL 코어 라이브러리 정의된 태그와 비슷하다.

| 엘리멘트 예                                                  | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `<if test="조건">SQL 문</if>`                                | test 속성이 지정된 조건이 참이면 `<if>` 태그의 내용을 반환한다. |
| `<choose><when test="조건1>SQL 문</when><otherwise>SQL 문</otherwise></choose>"` | 일치하는 조건이 없으면 otherwise의 내용을 반환한다.          |
| `<where><if test="조건1">SQL문</when><if test="조건2">SQL문</when></where>` | where 안의 하위 태그를 실행하고 나서 반환값이 있으면 where 절을 만들어 반환하고 없으면 where 절을 반환하지 않는다. |
| `<trim prefix="단어" prefixOverrides="문자열|문자열"><if test="조건">SQL문</when></trim>` | trim태그는 특정 단어로 시작하는 SQL문을 반환하고 싶을 때 사용한다. prefix는 반환값 앞에 붙일 접두사, prefixOverrides는 반환값에서 제거해야하는 접두어를 지정한다. |
| `<set><if test="조건">SQL문</when></set>`                    | update문의 set 절을 만들 때 사용한다.                        |
| `<foreach item="항목" index="인덱스" collection="목록" open="시작문자열" close="종료문자열" separator="구분자"></foreach>` | 목록의 값을 가지고 SQL문을 만들 때 사용한다. 특히 in(값, 값) 조건을 만들 때 좋다 |
| `<bind name="변수명" value="값"/>`                           | 변수를 생성할 때 사용한다.                                   |

#### 동적 SQL로 목록 조회

> MySqlProjectDao.xml

```xml
  <select id="selectList" resultMap="projectResultMap">
	  select PNO, PNAME, STA_DATE, END_DATE, STATE
	  from PROJECTS
	  order by PNO desc
  </select>

  <select id="selectList" parameterType="map" resultMap="projectResultMap">
    select PNO, PNAME, STA_DATE, END_DATE, STATE
    from PROJECTS
    order by
    <choose> 
        <when test="orderCond == 'TITLE_ASC'">PNAME asc</when>
        <when test="orderCond == 'TITLE_DESC'">PNAME desc</when>
<!-- 생략 -->
        <otherwise>PNO desc</otherwise>
    </choose>
  </select>
```

> ProjectList.jsp

```jsp
<h1>프로젝트 목록</h1>
<p><a href='add.do'>신규 프로젝트</a></p>
<table border="1">
<tr>
  <th><c:choose>
    <c:when test="${orderCond == 'PNO_ASC'}">
      <a href="list.do?orderCond=PNO_DESC">번호↑</a>
    </c:when>
    <c:when test="${orderCond == 'PNO_DESC'}">
      <a href="list.do?orderCond=PNO_ASC">번호↓</a>
    </c:when>
    <c:otherwise>
      <a href="list.do?orderCond=PNO_ASC">번호︎</a>
    </c:otherwise>
  </c:choose></th>
<!-- 생략 -->
  <th></th>
</tr>
```

> ProjectListController.java

```java
@Component("/project/list.do")
public class ProjectListController implements Controller, DataBinding {
  ProjectDao projectDao;
  
  public ProjectListController setMemberDao(ProjectDao projectDao) {
    this.projectDao = projectDao;
    return this;
  }
  
  public Object[] getDataBinders() {
    return new Object[]{
        "orderCond", String.class
    };
  } 

  @Override
  public String execute(Map<String, Object> model) throws Exception {
  	HashMap<String,Object> paramMap = new HashMap<String,Object>();
  	paramMap.put("orderCond", model.get("orderCond"));
  	
    model.put("projects", projectDao.selectList(paramMap));
    return "/project/ProjectList.jsp";
  }
}
```

> ProjectDao.java

```java
public interface ProjectDao {
  List<Project> selectList(HashMap<String,Object> paramMap) throws Exception;
  int insert(Project project) throws Exception;
  Project selectOne(int no) throws Exception;
  int update(Project project) throws Exception;
  int delete(int no) throws Exception;
}
```

> MySqlProjectDao.java

```java
@Component("projectDao")
public class MySqlProjectDao implements ProjectDao {
  SqlSessionFactory sqlSessionFactory;

  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }

  public List<Project> selectList(HashMap<String,Object> paramMap) 
  		throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
      return sqlSession.selectList("spms.dao.ProjectDao.selectList", paramMap);
    } finally {
      sqlSession.close();
    }
  }
// 생략
}
```

#### 동적 SQL로 UPDATE

> MySqlProjectDao.xml

```xml
  <update id="update" parameterType="project">
    update PROJECTS set
      PNAME=#{title},
      CONTENT=#{content},
      STA_DATE=#{startDate},
      END_DATE=#{endDate},
      STATE=#{state},
      TAGS=#{tags}
    where PNO=#{no}
  </update>

  <update id="update" parameterType="map">
    update PROJECTS 
    <set>
      <if test="title != null">PNAME=#{title},</if>
      <if test="content != null">CONTENT=#{content},</if>
      <if test="startDate != null">STA_DATE=#{startDate},</if>
      <if test="endDate != null">END_DATE=#{endDate},</if>
      <if test="state != null">STATE=#{state},</if>
      <if test="tags != null">TAGS=#{tags}</if>
    </set>
    where PNO=#{no}
  </update>
```

> MySqlProjectDao.java

```java
@Component("projectDao")
public class MySqlProjectDao implements ProjectDao {
  SqlSessionFactory sqlSessionFactory;

  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }
// 생략
  public int update(Project project) throws Exception { 
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
    	Project original = sqlSession.selectOne(
    			"spms.dao.ProjectDao.selectOne", project.getNo());
    	
    	Hashtable<String,Object> paramMap = new Hashtable<String,Object>();
        
        // 원래의 값과 사용자가 입력한 값을 비교하여 값이 바뀌었다면 Map 객체에 저장한다.
    	if (!project.getTitle().equals(original.getTitle())) {
    		paramMap.put("title", project.getTitle());
    	}
    	if (!project.getContent().equals(original.getContent())) {
    		paramMap.put("content", project.getContent());
    	}
    	if (project.getStartDate().compareTo(original.getStartDate()) != 0) {
    		paramMap.put("startDate", project.getStartDate());
    	}
    	if (project.getEndDate().compareTo(original.getEndDate()) != 0) {
    		paramMap.put("endDate", project.getEndDate());
    	}
    	if (project.getState() != original.getState()) {
    		paramMap.put("state", project.getState());
    	}
    	if (!project.getTags().equals(original.getTags())) {
    		paramMap.put("tags", project.getTags());
    	}
    	// 바뀐 값이 있다면 update문을 실행
    	if (paramMap.size() > 0) {
    		paramMap.put("no", project.getNo());
    		int count = sqlSession.update("spms.dao.ProjectDao.update", paramMap);
    		sqlSession.commit();
    		return count;
    	} else {
    		return 0;
    	}
    } finally {
      sqlSession.close();
    }
  }  
// 생략
}
```

## 제 8장 스프링 IoC 컨테이너

Gradle : 애플리케이션 빌드 자동화 도구

* 컴파일, 테스트, 빌드, 배치 등을 자동화할 수 있다.

Groovy : Gradle의 빌드 스크립트를 작성할 때 사용되는 프로그래밍 언어

* 파이썬이나 루비, 펄과 비슷한 동적 프로그래밍 언어이다.
* 스크립팅 언어의 특징을 갖고 있으면서도 컴파일 방식으로 동작한다.

* Groovy DSL(Domain-Specific Language)은 빌드 스크립트를 작성하기에 XML보다 훨씬 유연한 구조를 제공한다.
* 자바 가상머신에서 실행되기 때문에 자바와 연동이 쉽다(자바의 클래스를 직접 사용 가능)

```groovy
def a = 20 // 동적 타입 바인딩
a = "문자열"
b = "문자열" // def 생략 가능

int a = 20
a = "문자열" // 오류 발생

java.util.Date a = new java.util.Date()
Date b = new Date()
```

***

### 스프링 IoC 컨테이너 사용 준비

### 의존성 주입(DI)과 역제어(IoC)

* 역제어의 한 가지 형태가 의존성 주입인 것이다.

* 역제어: 개발자가 작성한 코드의 흐름에 따라 제어가 이루어지는게 아니라 외부에 의해 코드의 흐름이 바뀌는 것

### Gradle 프로젝트

| 파일 및 디렉토리  | 설명                                              |
| ----------------- | ------------------------------------------------- |
| .gradle           | Gradle 빌드 도구와 관련된 파일을 두는 폴더        |
| .settings         | 이클립스와 관련된 설정 파일을 두는 폴더           |
| bin               | 컴파일된 자바 클래스 파일을 두는 폴더             |
| build             | Gradle 빌드의 실행 결과물이 놓이는 폴더           |
| src/main/java     | 자바 소스 파일을 두는 폴더                        |
| src/main/resource | 애플리케이션이 참조하는 파일을 두는 폴더          |
| src/test/java     | 단위 테스트 관련 자바 소스 파일을 두는 폴더       |
| src/test/resource | 단위 테스트를 수행할 때 참조하는 파일을 두는 폴더 |
| .classpath        | 이클립스가 참조하는 클래스 경로 설정 파일         |
| .project          | 이클립스 프로젝트 설정 파일                       |
| build.gradle      | Gradle 빌드 설정 파일                             |

![image](https://github.com/siwoo1627/Today-I-Learn/assets/114638386/d237cffb-60ed-43f4-9f75-5448bcadf1e4)

***

Gradle 플러그인

: 자주 사용할 만한 빌드 명령어를 미리 작성하여 묶어 놓은 일종의 라이브러리(자바의 유틸리티 클래스)

> build.gradle

```groovy
apply plugin: 'java'
apply plugin: 'eclipse-wtp'
apply plugin: 'war'

compileJava.options.encoding = 'UTF-8'
sourceCompatibility = 1.7
version = '1.0'

eclipse {
  wtp {
    facet {
      facet name: 'jst.web', version: '3.0' // Servlet Spec Version 지정
      facet name: 'jst.java', version: '1.7' // Java Version 지정, 1.7 ...
    }
  }
}

jar {
  manifest {
    attributes 'Implementation-Title': 'Gradle Quickstart', 
      'Implementation-Version': version
  }
}

repositories {
  mavenCentral()
}

dependencies {
  compile 'org.springframework:spring-context:4.0.3.RELEASE'
  compile group: 'commons-collections', 
    name: 'commons-collections', 
    version: '3.2'
  testCompile group: 'junit', 
    name: 'junit', 
    version: '4.+'
}

test {
  systemProperties 'property': 'value'
}

uploadArchives {
  repositories {
    flatDir {
      dirs 'repos'
    }
  }
}
```

* `apply plugin: 'java'`: 자바 플러그인 사용
* `jar` 작업은 java 플러그인에 속해 있으면서 .jar 파일을 생성하는 일을 한다.
* `repositories `: 의존 라이브러리를 가져올 저장소 설정
  * `mavenCentral()`: 의존 라이브러리를 찾기 위한 저장소로 메이븐(Maven) 중앙 서버를 지정

* `dependencies{}`: 의존 라이브러리에 대한 정보
  * `dependencies{[설정 이름] [의존 라이브러리 정보]}`
  * 설정이름
    * `compile`: compile 이름으로 등록한 라이브러리는 compileJava 작업을 수행할 때 사용한다.
    * `testCompile`: testCompile 이름으로 등록한 라이브러리는 compileTestJava 작업을 수행할 때 사용한다.
  * 의존 라이브러리 정보
    * `[설정이름] 'group:name:version:classifier'`
    * `[설정이름] group: '그룹명', name: '라이브러리 이름', version: '라이브러리 버전', classifier: '분류 접미사'`
  * `compile 'org.springframework:spring-context:4.0.3.RELEASE'`: spring-context 라이브러리를 가져오기 위해 compile 이름으로 등록함

* `test {}`: 테스트 정보 설정
  * `systemProperties 'property': 'value'`: 속성을 통해 직접 값을 설정

* `uploadArchives {}`: 아카이브 파일(.jar) 배포, 프로젝트를 빌드한 후 생성된 산출물은 uploadArchives  작업을 통해 저장소에 배포할 수 있다. 저장소에 대한 정보는 uploadArchives 블럭 안에 repositories블록을 사용하여 설정한다.
  * `flatDir`: 로컬 폴더를 저장소로 지정

***

### XML 기반 빈 관리 컨테이너

: 스프링 프레임워크는 이전의 spms.context.ApplicationContexxt 클래스보다 뛰어난 객체 관리 컨테이너(IoC 컨테이너)를 제공한다. 스프링에서는 자바 객체를 빈(Bean)이라고하고, 객체 관리 컨테이너를 '빈 컨테이너'라고 부른다.

* 스프링 IoC 컨테이너는 XML과 애노테이션으로 빈 정보를 다룬다.

#### 스프링 빈 컨테이너 ClassPathXmlApplicationContext 사용

> Score.java

```java
public class Score {
	String 	name;
	float		kor;
	float		eng;
	float		math;
	
	public Score() { }
	
	public Score(String name, float kor, float eng, float math) {
		this.name = name;
		this.kor = kor;
		this.eng = eng;
		this.math = math;
	}
	@Override
	public String toString() {
	  return name + "," + kor + "," + eng + "," + math;
	}
	public float average() {
		return sum() / (float)3;
	}
	
	public float sum() {
		return kor + eng + math;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	// 생략
}
```

> beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
  <bean id="score" class="exam.test01.Score"/>
</beans>
```

* `<bean id="score" class="exam.test01.Score"/>`: 네임스페이스를 정의한 XML 스키마 파일의 위치를 지정, id는 객체의 식별자이며 빈 컨테이너에서 객체를 꺼낼 때 이 식별자를 사용한다.

  > 자바일 경우 = new exam.test01.Score();

> Test.java

```java
package exam.test01;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test01/beans.xml");
		
		Score score = (Score) ctx.getBean("score");
		
		System.out.println("합계:" + score.sum());
		System.out.println("평균:" + score.average());
	}
}
```

* ClassPathXmlApplicationContext 클래스를 사용하여 IoC 컨테이너를 준비한다.

#### name 속성으로 빈 이름 지정하기

: `<bean>` 태그 사용 시 id 대신 name 속성에 빈 이름을 지정할 수 있다.

```xml
  <bean name="score" class="exam.test02.Score"/>
  <bean name="score2,score3,score4" class="exam.test02.Score"/>
  <!-- <bean name="score2 score3 score4" class="exam.test02.Score"/> -->
  <!-- <bean name="score2 score3 score4" class="exam.test02.Score"/> -->
  <bean name="score-ok!" class="exam.test02.Score"/>
```

* 구분자를 사용하면 인스턴스에 대해 여러 개의 이름을 붙일 수 있다. name의 첫 번째 이름은 빈의 이름으로 사용되고 나머지는 빈의 별명이 됨
  * score2가 이름이고 score3, score4가 별명이다.

> Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test02/beans.xml");
		
		System.out.println("[컨테이너에 보관된 객체의 이름 출력]");
		for (String name : ctx.getBeanDefinitionNames()) {
			System.out.println(name);
		}
		
		System.out.println("[score2의 별명 출력]");
		for (String alias : ctx.getAliases("score2")) {
			System.out.println(alias);
		}
		
		// name="score"
		Score score = (Score) ctx.getBean("score");
		
		// name="score2,score3,score5" 
		Score score2 = (Score) ctx.getBean("score2");
		Score score3 = (Score) ctx.getBean("score3");
		Score score4 = (Score) ctx.getBean("score4");
		
		// name="score-ok!"
		Score scoreOk = (Score) ctx.getBean("score-ok!");
		
		System.out.println("[빈 꺼내기]");
		if (score != null) System.out.println("score 찾았음.");
		if (score2 != null) System.out.println("score2 찾았음.");
		if (score3 != null) System.out.println("score3 찾았음.");
		if (score3 != null) System.out.println("score4 찾았음.");
		if (scoreOk != null) System.out.println("score-ok! 찾았음.");
		
		System.out.println("[생성된 빈 비교]");
		if (score == score2) System.out.println("score == score2");
		if (score2 == score3) System.out.println("score2 == score3");
		if (score3 == score4) System.out.println("score3 == score4");
		if (score4 == scoreOk) System.out.println("score4 == scoreOk");
	}
}
```

#### 익명(anonymous) 빈 선언

: 빈의 이름을 지정하지 않음

```xml
  <bean class="exam.test03.Score"/> <!-- exam.test03.Score#0 -->
  <bean class="exam.test03.Score"/> <!-- exam.test03.Score#1 -->
```

* 컨테이너에 보관할 때 "패키지 이름+클래스 이름 + #인덱스"를 빈의 이름으로 사용한다.
  * 동일 클래스 객체가 여러 개 생성될 경우를 대비해 #인덱스가 자동으로 붙는다

>Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test03/beans.xml");
		
		System.out.println("[컨테이너에 보관된 객체의 이름 출력]");
		for (String name : ctx.getBeanDefinitionNames()) {
			System.out.println(name);
		}
		
		System.out.println("[exam.test03.Score#0의 별명 출력]");
		for (String alias : ctx.getAliases("exam.test03.Score#0")) {
			System.out.println(alias);
		}
		
		System.out.println("[익명 빈 꺼내기]");
		Score score1 = (Score) ctx.getBean("exam.test03.Score");
		Score score2 = (Score) ctx.getBean("exam.test03.Score#0");
		if (score1 == score2) System.out.println("score == score#0"); // 같음
		
		Score score3 = (Score) ctx.getBean("exam.test03.Score#1");
		if (score1 != score3) System.out.println("score != score#1"); // 다름
		
		System.out.println("[클래스 타입으로 빈 꺼내기]");
		Score score4 = (Score) ctx.getBean(exam.test03.Score.class); // 여러개이므로 오류
	}
}
```

### 생성자와 프로퍼티 설정

#### 생성자 설정

```xml
  <bean id="score1" class="exam.test04.Score">
      <constructor-arg><value type="java.lang.String">홍길동</value></constructor-arg>
      <constructor-arg><value type="float">91</value></constructor-arg>
      <constructor-arg><value type="float">92</value></constructor-arg>
      <constructor-arg><value type="float">93</value></constructor-arg>
  </bean>
  <bean id="score2" class="exam.test04.Score">
      <constructor-arg><value>임꺽정</value></constructor-arg>
      <constructor-arg><value>81</value></constructor-arg>
      <constructor-arg><value>82</value></constructor-arg>
      <constructor-arg><value>83</value></constructor-arg>
  </bean> 
  <bean id="score4" class="exam.test04.Score">
      <constructor-arg value="이순신"/>
      <constructor-arg value="100"/>
      <constructor-arg value="98"/>
      <constructor-arg value="99"/>
  </bean>
  <bean id="score5" class="exam.test04.Score">
      <constructor-arg value="70" index="3"/>
      <constructor-arg value="50" index="1"/>
      <constructor-arg value="강감찬" index="0"/>
      <constructor-arg value="60" index="2"/>
  </bean>
```

* `<constructor-arg><value type="java.lang.String">홍길동</value></constructor-arg>`: 태그를 사용하여 호출될 생성자를 지정할 수 있다. 호출할 생성자는 매개변수 값에 의해 결정된다.

  > 자바일 경우 = new Score("홍길동", 91, 92, 93);

* `constructor-arg` 태그 순서로 진행되므로 type 생략 가능

* `index` 속성을 이용하여 매개변수의 순서를 지정 가능

> Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test04/beans.xml");
		
		Score score1 = (Score) ctx.getBean("score1");
		System.out.println(score1);
		
		Score score2 = (Score) ctx.getBean("score2");
		System.out.println(score2);
	}
}
```

#### 프로퍼티 설정

```xml
  <bean id="score1" class="exam.test05.Score">
    <property name="name"><value>홍길동</value></property>
    <property name="kor"><value>100</value></property>
    <property name="eng"><value>95</value></property>
    <property name="math"><value>90</value></property>
  </bean>
  
  <bean id="score2" class="exam.test05.Score">
    <property name="name" value="임꺽정"/>
    <property name="kor" value="85"/>
    <property name="eng" value="99"/>
    <property name="math" value="100"/>
  </bean>
```

> 자바 코드로 표현
>
> Score score1 = new Score();
>
> score1.setName("홍길동");
>
> score1.setkor(100);
>
> score1.seteng(95);
>
> score1.setmath(90);

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test05/beans.xml");
		
		Score score1 = (Score) ctx.getBean("score1");
		System.out.println(score1);

		Score score2 = (Score) ctx.getBean("score2");
		System.out.println(score2);
	}
}
```

#### `<bean>`의 속성을 이용하여 생성자 및 프로퍼티 설정하기

: 스프링은 property 태그를 사용하지 않고 프로퍼티 값을 설정 및 constructor-arg 태그를 사용하지 않고 생성자 매개변수 값을 설정하는 방법을 제공한다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
  
  <bean id="score1" class="exam.test06.Score"
      p:name="홍길동" p:kor="100" p:eng="95" p:math="90"/>
  
  <bean id="score2" class="exam.test06.Score"
      c:name="임꺽정" c:kor="80" c:eng="90" c:math="100"/>
  
</beans>
```

*  `xmlns:p="http://www.springframework.org/schema/p"`
  * 네임스페이스 별명이 'p'이므로 `p:name` 형식으로 속성을 추가한다.
* `xmlns:c="http://www.springframework.org/schema/c"`
  * c는 생성자를 의미한다.

### 의존 객체 주입

어떤 객체가 작업을 수행하기 위해 다른 객체를 지속적으로 사용한다면 그 사용되는 객체를 의존 객체라 부른다. 보통 지속적으로 사용할 객체는 프로퍼티에 보관한다.

> Engine.java

```java
public class Engine {
	String 	maker; // 제조사
	int 		cc; // 배기량
	
	public Engine() {}
	
	public Engine(String maker) {
		this.maker = maker;
	}

	public String getMaker() {
		return maker;
	}

	public void setMaker(String maker) {
		this.maker = maker;
	}

	public int getCc() {
		return cc;
	}

	public void setCc(int cc) {
		this.cc = cc;
	}
	
	@Override
	public String toString() {
	  return "[Engine:" + maker + "," + cc + "]";
	}
}
```

> Tire.java

```java
public class Tire {
	String 	maker; // 제조사
	String	spec; // 규격
	Date		createdDate; //제조일
	
	public String getMaker() {
		return maker;
	}
	
	public void setMaker(String maker) {
		this.maker = maker;
	}
	
	public String getSpec() {
		return spec;
	}
	
	public void setSpec(String spec) {
		this.spec = spec;
	}
	
	public Date getCreatedDate() {
		return createdDate;
	}
	
	public void setCreatedDate(Date createdDate) {
		this.createdDate = createdDate;
	}
	
	@Override
	public String toString() {
	  return "[Tire:" + maker + "," + spec + 
	  		((createdDate != null)?("," + createdDate.toString()):"") + "]";
	}
}
```

> Car.java

```java
public class Car {
	String			model; // 모델명
	Engine 			engine; // 엔진
	Tire[]			tires; // 타이어
	
	public Car() {}
	
	public Car(String model, Engine engine) {
		this.model = model;
		this.engine = engine;
	}
	
	public String getModel() {
		return model;
	}
	
	public void setModel(String model) {
		this.model = model;
	}
	
	public Engine getEngine() {
		return engine;
	}
	
	public void setEngine(Engine engine) {
		this.engine = engine;
	}
	
	public Tire[] getTires() {
		return tires;
	}

	public void setTires(Tire[] tires) {
		this.tires = tires;
	}

	@Override
	public String toString() {
		StringBuffer carInfo = new StringBuffer();
		carInfo.append("[Car:" + model);
		carInfo.append("\n  " + engine.toString());
		if (tires != null) {
			for (Tire tire : tires) {
				carInfo.append("\n  " + tire.toString());
			}
		}
		carInfo.append("\n]");
	  return carInfo.toString();
	}
}
```

> beans.xml

```xml
  <bean id="engine1" class="exam.test07.Engine" c:maker="Hyundai" p:cc="1998"/>
<!-- 
Engine engine1 = new Engine("Hyndai");
engine1.setCc(1998);
-->
  
  <bean id="car1" class="exam.test07.Car">
      <property name="model"><value>Avante</value></property>
      <property name="engine"><ref bean="engine1"/></property>
  </bean>
<!-- 
Car car = new Car();
car1.setModel("Avante");
cat1.setEngine(engine1);
-->
  <bean id="car2" class="exam.test07.Car">
      <property name="model" value="Sonata"/>
      <property name="engine" ref="engine1"/>
  </bean>
  
  <bean id="car3" class="exam.test07.Car" p:model="Grandeur" p:engine-ref="engine1"/>
  <bean id="car4" class="exam.test07.Car" c:model="Equus" c:engine-ref="engine1"/>
<!-- 
Car car4 = new Car("Equus",engine1);
-->
```

> Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test07/beans.xml");
		
		Car car1 = (Car) ctx.getBean("car1");
		System.out.println(car1);
		
		Engine engine = (Engine) ctx.getBean("engine1");
		engine.cc = 3000;
		
		System.out.println(car1);
		
		Car car2 = (Car) ctx.getBean("car2");
		System.out.println(car2);
		
		Car car3 = (Car) ctx.getBean("car3");
		System.out.println(car3);
		
		Car car4 = (Car) ctx.getBean("car4");
		System.out.println(car4);
	}
}
```

engine1을 변경하면 car1, car2, car3 도 공유하므로 모두 변경된다.

#### 개별 인스턴스 주입하기

: 이미 존재하는 빈을 주입하는 것이 아닌, 새로 빈을 만들어 주입

```xml
	<bean id="car1" class="exam.test08.Car">
		<constructor-arg value="Avante" />
		<constructor-arg>
			<bean class="exam.test08.Engine" p:maker="Hyundai" p:cc="1495" />
		</constructor-arg>
	</bean>
<!--
Engine temp = new Engine();
temp.setMaker("Hyndai");
temp.setCc(1495);
Car car1 = new Car("Avante",temp);
-->
	<bean id="car2" class="exam.test08.Car">
		<property name="model" value="Sonata" />
		<property name="engine">
			<bean class="exam.test08.Engine" p:maker="Hyundai" p:cc="1997" />
		</property>
	</bean>
```

> Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test08/beans.xml");
		
		Car car1 = (Car) ctx.getBean("car1");
		System.out.println(car1);
		
		Car car2 = (Car) ctx.getBean("car2");
		System.out.println(car2);
		
		Engine engine = car1.engine;
		engine.cc = 3000;
		
		System.out.println(car1);
		System.out.println(car2);
	}
}
```

자신만의 엔진을 가지고 있으며 cc를 바꿔도 car1의 엔진만 변경된다.

### 컬렉션 값 주입

배열이나 List와 같이 여러 개의 값을 저장하고 다루는 객체를 '컬랙션'이라고 한다.

#### 배열 프로퍼티의 값 주입

```xml
	<bean id="car1" class="exam.test09.Car">
		<constructor-arg value="Avante" />
		<constructor-arg>
			<bean class="exam.test09.Engine" p:maker="Hyundai" p:cc="1495" />
		</constructor-arg>
		<property name="tires">
			<list>
				<bean class="exam.test09.Tire" p:maker="Kumho" p:spec="P185/65R14" />
				<bean class="exam.test09.Tire" p:maker="Kumho" p:spec="P185/65R14" />
				<bean class="exam.test09.Tire" p:maker="Hankook" p:spec="P205/65R14" />
				<bean class="exam.test09.Tire" p:maker="Hankook" p:spec="P205/65R14" />
			</list>
		</property>
	</bean>
<!--
Engine temp = new Engine();
temp.setMaker("Hydai");
temp.setCc(1495);
Car car1 = new Car("Avante",temp);
Tire temp2 = new Tire[]{new Tire(), new Tire(), new Tire(),new Tire()};
temp2[0].setMaker("Kumho");
temp2[0].setSpec("P185/65R14");
...
car1.setTire(temp2);
------------------------
<list>
	<value>간단한 상수값</value>
	<ref bean="빈 레퍼런스" />
	<null/>
	<bean class="클래스명(패키지명 포함)"/>
</list>
<property name="프로퍼티 이름">
	<value>간단한 상수값</value>
	<ref bean="빈 레퍼런스" />
	<null/>
	<bean class="클래스명(패키지명 포함)"/>
</property>
-->
```

> Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test09/beans.xml");
		
		Car car1 = (Car) ctx.getBean("car1");
		for (Tire tire : car1.getTires()) {
			System.out.println(tire);
		}
	}
}
```

#### Map과 Properties 값 주입

Map이나 Properties일 경우 key와 value를 한 쌍으로 묶어서 저장한다.

> Tire.java

```java
public class Tire {
	String 			maker; // 제조사
	Properties	spec; // 규격
	Date				createdDate; //제조일
	
	public String getMaker() {
		return maker;
	}
	
	public void setMaker(String maker) {
		this.maker = maker;
	}
	
	public Properties getSpec() {
		return spec;
	}

	public void setSpec(Properties spec) {
		this.spec = spec;
	}

	public Date getCreatedDate() {
		return createdDate;
	}
	
	public void setCreatedDate(Date createdDate) {
		this.createdDate = createdDate;
	}
	
	@Override
	public String toString() {
		StringBuffer specInfo = new StringBuffer();
		if (spec != null) {
			for (Entry<Object,Object> entry : spec.entrySet()) {
				specInfo.append(entry.getKey() + ":" + entry.getValue() + ",");
			}
		}
	  return "[Tire:" + maker + "," + 
				specInfo.toString() + 
	  		((createdDate != null)?("," + createdDate.toString()):"") + "]";
	}
}
```

> Car.java

```java
public class Car {
	String							model; // 모델명
	Engine 							engine; // 엔진
	Tire[]							tires; // 타이어
	Map<String,Object> 	options; //선택사항
	
	public Car() {}
	
	public Car(String model, Engine engine) {
		this.model = model;
		this.engine = engine;
	}
	
	public String getModel() {
		return model;
	}
	
	public void setModel(String model) {
		this.model = model;
	}
	
	public Engine getEngine() {
		return engine;
	}
	
	public void setEngine(Engine engine) {
		this.engine = engine;
	}
	
	public Tire[] getTires() {
		return tires;
	}

	public void setTires(Tire[] tires) {
		this.tires = tires;
	}

	public Map<String, Object> getOptions() {
		return options;
	}

	public void setOptions(Map<String, Object> options) {
		this.options = options;
	}

	@Override
	public String toString() {
		StringBuffer carInfo = new StringBuffer();
		carInfo.append("[Car:" + model);
		carInfo.append("\n  " + engine.toString());
		if (tires != null) {
			for (Tire tire : tires) {
				carInfo.append("\n  " + tire.toString());
			}
		}
		carInfo.append("\n]");
	  return carInfo.toString();
	}
}
```

> beans.xml

```xml
	<bean id="spareTire" class="exam.test10.Tire">
		<property name="maker" value="Hyundai" />
		<property name="spec">
			<props>
				<prop key="width">205</prop>
				<prop key="ratio">65</prop>
				<prop key="rim.diameter">14</prop>
			</props>
		</property>
	</bean>
<!--
Tire spareTire = new Tire();
spareTire.Maker("Hyundai");
Properties temp = new Properties();
temp.setProperty("width","205");
temp.setProperty("ratio","65");
temp.setProperty("rim.diameter","14");
spareTire.setSpec(temp);
-->
	<bean id="car1" class="exam.test10.Car">
		<constructor-arg value="Avante" />
		<constructor-arg>
			<bean class="exam.test10.Engine" p:maker="Hyundai" p:cc="1495" />
		</constructor-arg>
<!-- 
Car car1 = new Car("Avante",....);
-->
		<property name="options">
			<map>
				<entry>
					<key>
						<value>sunroof</value>
					</key>
					<value>yes</value>
				</entry>
				<entry key="airbag" value="dual" />
				<entry key="sparetire">
					<ref bean="spareTire" />
				</entry>
			</map>
		</property>
<!-- 
Map<String,Object> tempMap = new Map<String,Object>;
car1.setOptions(tempMap);
tempMap.put("sunroof","yes");
tempMap.put("airbag","dual");
tempMap.put("sparetire", spareTire);
-->
	</bean>

```

> Test.java

```java
public class Test {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext ctx = 
				new ClassPathXmlApplicationContext("exam/test10/beans.xml");
		
		System.out.println("[Propoerties 타입]---------------------");
		Tire spareTire = (Tire) ctx.getBean("spareTire");
		for (Entry<Object,Object> entry : spareTire.getSpec().entrySet()) {
			System.out.println(entry.getKey() + ":" + entry.getValue());
		}
		
		System.out.println("[Map 타입]---------------------");
		Car car1 = (Car) ctx.getBean("car1");
		for (Entry<String,Object> entry : car1.getOptions().entrySet()) {
			System.out.println(entry.getKey() + ":" + entry.getValue());
		}
	}
}
```

### 팩토리 메서드와 팩토리 빈

8.7.1 스태틱 팩토리 메서드를 이용한 간접 객체 생성

8.7.2 인스턴스 팩토리 메서드를 이용한 간접 객체 생성

8.7.3 스프링 규칙에 따라서 팩토리 빈 만들기



8.8 빈의 범위 설정

8.8.1 싱글톤과 프로토타입



8.9 날짜 값 주입

8.9.1 SimpleDateFormat 클래스와 인스턴스 팩토리 메서드 활용

8.9.2 커스텀 프로퍼티 에디터 활용



8.10 애노테이션을 이용한 의존 객체 자동 주입

8.10.1 @Autowired 적용

8.10.2 @Autowired의 required 속성

8.10.3 @Qualifier로 주입할 객체를 지정하기

8.10.4 @Autowired + @Qualifier = @Resource



8.11 빈 자동 등록

8.11.1 @Component가 붙은 클래스를 자동으로 찾기



8.12 Gradle 적용

8.12.1 Gradle 적용 준비

8.12.2 Gradle 설정에 의존 라이브러리 추가

8.12.3 Gradle 빌드

8.12.4 톰캣 서버에 웹 애플리케이션 배치 및 실행



8.13 스프링 IoC 컨테이너 적용

8.13.1 mybatis 관련 의존 라이브러리 추가

8.13.2 Gradle 빌드



~835p