## 제 2장 웹 프로그래밍 기초 다지기

Header : 서버가 요청을 처리할 때 참고하라고 클라이언트에서 웹 서버에게 알려주는 정보

* 일반 헤더: 요청이나 응답 모두에 적용할 수 있는 헤더
  * Cache-Control, Transfer-Encoding 등
* 요청/응답 헤더:  요청 또는 응답 중 하나에만 적용하는 헤더
  * Accept-Charset, Referer, Host, User-Agent 등
* 엔티티 헤더: 보내거나 받는 본문 데이터를 설명하는 헤더
    *   Allow, Content-Encoding, Content-Type 등


| 프로토콜                                         | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| FTP(File Transfer Protocol)                      | 클라이언트와 서버 간에 파일을 주고받기 위해 만든 통신 규약   |
| Telnet 프로토콜                                  | 인터넷이나 LAN 상에서 문자 기반으로 원격의 컴퓨터를 제어하기 위해 만든 통신 규약, 요즘은 보안때문에 SSH(Secure Shell) 프로토콜 기반 원격 접속 프로그램을 주로 사용 |
| XMPP(Extexsible Messaging and Presence Protocol) | 인스턴스 메시지 및 사용자의 접속 상태 정보를  교환할 목적으로 만든 통신 규약이며 Google Talk가 이 프로토콜을 기반으로 통신한다. |
| SMPT(Simple Mail Transfer Protocol)              | 인터넷 상에서 메일을 보내기 위한 통신 규약, POP3(Post Office Protocol version3)는 이메일을 가져 오는데 사용하는 통신 규약이며 POP3는 이메일을 가져온 후 서버의 메일을 삭제한다. |
| IMAP(Internet Message Access Protocol)           | POP3와 달리 이메일을 가져온 뒤에 서버의 메일을 지우지 않으며 요즘처럼 여러 대의 장비에서 이메일을 조회하는 경우에 적합하다. 단, POP3에 비해 통신 트래픽이 높은 것이 단점 |
| LDAP(Lightweight Directory Access Protocol)      | 디렉터리 서비스에 등록된 자원들을 찾는 통신 규약이다.        |
| IRC(Internet Relay Chat)                         | 실시간 채팅을 위해 만든 통신 규약이다.                       |

## 제 3장 서블릿 프로그래밍

웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI(Common Gateway Interface)라고 하고, 이렇게 웹 서버에 의해 실행되며 CGI 규칙에 따라서 웹 서버와 데이터를 주고 받도록 작성된 프로그램을 CGI프로그램이라고 한다.

* CGI는 C,C++,Java 등 컴파일 언어는 기계어로 번역된 코드를 바로 실행하기 때문에 실행속도가 빠르지만 수정 시마다 다시 컴파일 및 재배포 해야한다.
* Perl, PHP,Python 등의 스크립트 방식은 실행할 때마다 소스 코드의 문법을 검증하고 해석해야 하기 때문에 실행속도는 느리지만 변경 사항이 발생하면 소스코드를 수정하고 저장만 하면 되므로 편리하다.

Servlet: 자바로 만든 CGI 언어

* 서블릿 컨테이너가 서블릿을 대신하여 CGI규칙에 따라 웹 서버와 데이터를 주고 받는다.

***

`web.xml`: 배치기술서 DD(Deployment Description) 이라고 부르며, 웹 애플리케이션 배치 정보를 담고 있는 파일이다.

* 서블릿을 만들고 DD파일에 배치정보를 등록하지 않으면 서블릿 컨테이너가 서블릿을 찾지 못한다.

GenericServlet : 하위 클래스에게 공통의 필드와 메서드를 상속해 주고자 존재한다(추상클래스)

* 서블릿 클래스가 필요로 하는 init(), destroy(), getServletConfig(), getServletInfo()를 미리 구현하여 상속해 준다.
* GenericServlet을 상속받는다면 service() 만 구현하면 된다.

> http://localhost:9999/Lesson03/calc?a=1&b=2

```java
public class CalculatorServlet extends GenericServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void service(ServletRequest request, ServletResponse response)
			throws ServletException, IOException {
		int a = Integer.parseInt( request.getParameter("a") );
		int b = Integer.parseInt( request.getParameter("b") );

		response.setContentType("text/plain");
		response.setCharacterEncoding("UTF-8");
		PrintWriter writer = response.getWriter();
		writer.println("a=" + a + "," + "b=" + b + "의 계산결과 입니다.");
		writer.println("a + b = " + (a + b));
		writer.println("a - b = " + (a - b));
		writer.println("a * b = " + (a * b));
		writer.println("a / b = " + ((float)a / (float)b));
		writer.println("a % b = " + (a % b));
    }
}
```

* `response.setContentType("text/plain");`: 클라이언트가 출력할 데이터 형식과 문자 집합을 지정, 출력할 데이터가 텍스트이고 별도의 메타 정보가 없는 순수한 텍스트임
* `response.setCharacterEncoding("UTF-8");`: 출력할 데이터의 문자 집합을 지정
* `PrintWriter writer = response.getWriter();`: 클라이언트로 출력할 수 있도록 출력 스트림 객체를 반환

## 제 4장 서블릿과 JDBC

### HttpServlet

```java
	// 생략
	PreparedStatement stmt = null; // insert이므로
	// Statement stmt = null; // select일 때

	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			DriverManager.registerDriver(new com.mysql.jdbc.Driver());
			conn = DriverManager.getConnection(
					"jdbc:mysql://localhost/studydb", //JDBC URL
					"study",	// DBMS 사용자 아이디
					"study");	// DBMS 사용자 암호
			stmt = conn.prepareStatement(
					"INSERT INTO MEMBERS(EMAIL,PWD,MNAME,CRE_DATE,MOD_DATE)"
					+ " VALUES (?,?,?,NOW(),NOW())");
			stmt.setString(1, request.getParameter("email")); // 첫번째 물음표
			stmt.setString(2, request.getParameter("password")); // 두번째 물음표
			stmt.setString(3, request.getParameter("name")); // 세번째 물음표
			stmt.executeUpdate();

			// 리다이렉트를 이용한 리프래시
			//response.sendRedirect("list");
            
			response.setContentType("text/html; charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.println("<html><head><title>회원등록결과</title></head>");
			// meta 태그를 이용한 리프래시
			out.println("<meta http-equiv='Refresh' content='1; url=list'>");
			out.println("<body>");
			out.println("<p>등록 성공입니다!</p>");
			out.println("</body></html>");
			// 리프래시 정보를 응답 헤더에 추가
			//response.addHeader("Refresh", "1;url=list");
            
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}

	}
```

* `HttpServlet`는 `GenericServlet`를 상속받으므로 service()가 아닌 doXXX()를 오버라이딩한다.
* doXXX()는 클라이언트 요청 방식에 따라 GET, POST, PUT 등으로 오버라이딩한다.

* 입력 매개변수의 번호는 1부터 시작한다.
* `response.addHeader("Refresh", "1;url=list");`: 1초 후 list로 이동한다.
* `response.sendRedirect("list");` 응답 결과를 출력하지 않고 이동한다.

| 비교 항목            | Statement                                                    | PreparedStatemen                                             |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 실행 속도            | 질의할 때마다 SQL 문을 컴파일한다.                           | SQL문을 미리 준비하여 컴파일해 둔다. 입력 매개변수 값만 추가하여 서버에 전송한다. 특히 여러 번 반복하여 질의하는 경우, 실행속도가 빠름 |
| 바이너리 데이터 전송 | 불가능                                                       | 가능                                                         |
| 프로그래밍 편의성    | SQL문 안에 입력 매개변수 값이 있어서 SQL 문이 복잡하고 매개변수가 여러 개인 경우 코드 관리가 힘들다 | SQL문과 입력 매개변수가 분리되어 있어 코드 작성이 편하다.    |

***

```java
@SuppressWarnings("serial")
/* 애노테이션을 이용하여 서블릿 배치 정보 설정
 * - 서블릿 초기화 파라미터도 애노테이션으로 처리 
 *
@WebServlet(
  urlPatterns={"/member/update"},
  initParams={
	  @WebInitParam(name="driver",value="com.mysql.jdbc.Driver"),
	  @WebInitParam(name="url",value="jdbc:mysql://localhost/studydb"),
	  @WebInitParam(name="username",value="study"),
	  @WebInitParam(name="password",value="study")
  }
)
*/
public class MemberUpdateServlet extends HttpServlet {
	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;
		try {
			Class.forName(this.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						this.getInitParameter("url"),
						this.getInitParameter("username"),
						this.getInitParameter("password")); 
			stmt = conn.createStatement();
			rs = stmt.executeQuery(
				"SELECT MNO,EMAIL,MNAME,CRE_DATE FROM MEMBERS" + 
				" WHERE MNO=" + request.getParameter("no"));	
			rs.next();
			
			response.setContentType("text/html; charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.println("<html><head><title>회원정보</title></head>");
			out.println("<body><h1>회원정보</h1>");
			out.println("<form action='update' method='post'>");
			out.println("번호: <input type='text' name='no' value='" +
				request.getParameter("no") + "' readonly><br>");
			out.println("이름: <input type='text' name='name'" +
				" value='" + rs.getString("MNAME")  + "'><br>");
			out.println("이메일: <input type='text' name='email'" +
				" value='" + rs.getString("EMAIL")  + "'><br>");
			out.println("가입일: " + rs.getDate("CRE_DATE") + "<br>");
			out.println("<input type='submit' value='저장'>");
			out.println("<input type='button' value='취소'" + 
				" onclick='location.href=\"list\"'>");
			out.println("</form>");
			out.println("</body></html>");
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch(Exception e) {}
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}
	}
	
	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		Connection conn = null;
		PreparedStatement stmt = null;
		try {
			Class.forName(this.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						this.getInitParameter("url"),
						this.getInitParameter("username"),
						this.getInitParameter("password")); 
			stmt = conn.prepareStatement(
					"UPDATE MEMBERS SET EMAIL=?,MNAME=?,MOD_DATE=now()"
					+ " WHERE MNO=?");
			stmt.setString(1, request.getParameter("email"));
			stmt.setString(2, request.getParameter("name"));
			stmt.setInt(3, Integer.parseInt(request.getParameter("no")));
			stmt.executeUpdate();
			
			response.sendRedirect("list");
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}
	}
}
```

* ```java
  @WebServlet(
    urlPatterns={"/member/update"},
    initParams={
  	  @WebInitParam(name="driver",value="com.mysql.jdbc.Driver"),
  	  @WebInitParam(name="url",value="jdbc:mysql://localhost/studydb"),
  	  @WebInitParam(name="username",value="study"),
  	  @WebInitParam(name="password",value="study")
    }
  )
  ```

  : 웹 애노테이션으로 DB연결 설정

  `Class.forName(this.getInitParameter("driver"));` driver에 해당하는 `com.mysql.jdbc.Driver` 가져옴

* `conn = DriverManager.getConnection(`: Driver로 가져온 db연결하여 사용



### 컨텍스트 초기화 매개변수

: 각 서블릿마다 JDBC 드라이버와 데이터베이스 연결에 대한 정보를 설정하지 않고 같은 웹 애플리케이션에 소속된 서블릿들이 공유하는 서블릿컨텍스트를 사용한다.

> web.xml

```xml
<!-- 컨텍스트 초기화 파라미터 -->
	<context-param>
		<param-name>driver</param-name>
		<param-value>com.mysql.jdbc.Driver</param-value>
	</context-param>
	<context-param>
		<param-name>url</param-name>
		<param-value>jdbc:mysql://localhost/studydb</param-value>
	</context-param>
	<context-param>
		<param-name>username</param-name>
		<param-value>study</param-value>
	</context-param>
	<context-param>
		<param-name>password</param-name>
		<param-value>study</param-value>
	</context-param>
```

```java
// 생략
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password")); 
			stmt = conn.createStatement();
// 생략
```

### 필터

: 서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술

```java
package spms.filters;

// 생략

@WebFilter(
	urlPatterns="/*",
	initParams={
		@WebInitParam(name="encoding",value="UTF-8")
	})
public class CharacterEncodingFilter implements Filter{
	FilterConfig config;
	
	@Override
	public void init(FilterConfig config) throws ServletException {
		this.config = config;
	}
	
	@Override
	public void doFilter(
			ServletRequest request, ServletResponse response,
			FilterChain nextFilter) throws IOException, ServletException {
		request.setCharacterEncoding(config.getInitParameter("encoding"));
        /* 서블릿이 실행되기 전에 해야 할 작업 */
        
        // 다음 필터를 호출, 더이상 필터가 없다면 서블릿의 service()가 호출됨
		nextFilter.doFilter(request, response);
        
        /* 서블릿이 실행한 후, 클라이언트에게 응답하기 전에 해야할 작업 */
	}

	@Override
	public void destroy() {}
}

```

> web.xml

```xml
	<!-- 필터 선언 --> 
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>spms.filters.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
	
	<!-- 필터 URL 매핑 -->
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
```

* `<url-pattern>/*</url-pattern>`: 모든 요청에 대해 필터 적용

## 제 5장 MVC 아키텍처

**JSP 프리컴파일**: 서버에 배치할 때 JSP 파일에 대해 자바 서블릿 클래스를 미리 생성하기도 한다. JSP 실행 요청이 들어 왔을 때, 곧바로 서블릿을 호출할 수 있어, JSP를 실행할 때마다 JSP 파일이 변경되었는지, JSP 파일에 대해 서블릿 파일이 있는지 매번 검사할 필요가 없어 컴파일하는 과정이 없으므로 실행속도가 빠르다.

단, JSP를 편집하면 서버를 다시 시작해야한다.

#### JSP 전용 태그 - 지시자

`<%@ 지시자 속성="값" 속성="값" ... %>`

* page: JSP페이지와 관련된 속성을 정의할 때 사용

  * ```jsp
    <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
    <!-- pageEncoding: 출력할 데이터 타입을 지정 -->
    ```

* taglib

* include

#### JSP 전용 태그 - 스크립트릿

`<@ 자바 코드 @>`

#### JSP 내장 객체

: 스트립트릿이나 표현식을 작성할 때 별도의 선언 없이 사용가능한 자바 객체

* request, response, pageContext, session, application, config, out, page, exception

#### JSP 전용 태그 - 선언문

`<%! 멤버 변수 및 메서드 선언 %>`

#### JSP 전용 태그 - 표현식

`<%= 결과를 반환하는 자바 표현식 %>`

```jsp
<input type="text" name="v1" size="4" value="<%=v1%>"> 
<option value="+" <%=selected[0]%>>+</option>
```

### 서블릿에서 뷰 분리하기

서블릿(Model+Controller) -> JSP(View)

#### 값 객체(VO) = 데이터 수송 객체(DTO)

: 데이터베이스에서 가져온 정보를 JSP 페이지에 전달할 목적으로 정보를 담은 객체

#### 회원 목록

```java
// UI 출력 코드를 제거하고, UI 생성 및 출력을 JSP에게 위임한다.
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;

		try {
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password")); 
			stmt = conn.createStatement();
			rs = stmt.executeQuery(
					"SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
					" FROM MEMBERS" +
					" ORDER BY MNO ASC");
			
			response.setContentType("text/html; charset=UTF-8");
			ArrayList<Member> members = new ArrayList<Member>();
			
			// 데이터베이스에서 회원 정보를 가져와 Member에 담는다.
			// 그리고 Member객체를 ArrayList에 추가한다.
			while(rs.next()) {
				members.add(new Member()
							.setNo(rs.getInt("MNO"))
							.setName(rs.getString("MNAME"))
							.setEmail(rs.getString("EMAIL"))
							.setCreatedDate(rs.getDate("CRE_DATE"))	);
			}
			
			// request에 회원 목록 데이터 보관한다.
			request.setAttribute("members", members);
			
			// JSP로 출력을 위임한다!!
			RequestDispatcher rd = request.getRequestDispatcher(
					"/member/MemberList.jsp");
			rd.include(request, response);
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch(Exception e) {}
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}

	}
}
```

```jsp
<%@page import="spms.vo.Member"%>
<%@page import="java.util.ArrayList"%>
<%@ page 
	language="java" 
	contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>회원 목록</title>
</head>
<body>
<h1>회원목록</h1>
<p><a href='add'>신규 회원</a></p>
<%
ArrayList<Member> members = (ArrayList<Member>)request.getAttribute(
								"members");
for(Member member : members) {
%>
<%=member.getNo()%>,
<a href='update?no=<%=member.getNo()%>'><%=member.getName()%></a>,
<%=member.getEmail()%>,
<%=member.getCreatedDate()%>
<a href='delete?no=<%=member.getNo()%>'>[삭제]</a><br>
<%} %>
</body>
</html>
```

**포워드(forward)**: 제어권을 넘기고 안돌아옴, ex) 예외 발생

```java
// 생략
	} catch (Exception e) {
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
			rd.forward(request, response);
// 생략
```

```jsp
<%@ page 
	language="java" 
	contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>시스템 오류!</title>
</head>
<body>
<p>요청을 처리하는 중에 문제가 발생하였습니다. 잠시 후에 다시 요청하시기 바랍니다.
만약 계속해서 이 문제가 발생된다면 시스템 운영팀(사내번호: 8282)에 연락하기 바랍니다.</p>
</body>
</html>
```

**인클루드(include)**: 제어권을 넘기고 그 서블릿이 작업이 끝나면 돌아옴, ex) Header, Tail

```jsp
<jsp:include page="/Header.jsp"/>
<!-- 생략 -->
<jsp:include page="/Tail.jsp"/>
```

### 데이터 보관소

데이터를 공유하기 위한 서블릿 기술

```java
보관소 객체.setAttribute(키, 값); // 값 저장
보관소 객체.getAttribute(키); // 값 저장
```

#### ServletContext

: 웹 애플리케이션이 시작될 때 생성되어 웹 애플리케이션이 종료될 때까지 유지된다. 

* application 변수를 통해 참조

```java
@SuppressWarnings("serial")
public class AppInitServlet extends HttpServlet {

	@Override
	public void init(ServletConfig config) throws ServletException {
		System.out.println("AppInitServlet 준비…");
		super.init(config);
		try {
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			Connection conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password"));
			
			sc.setAttribute("conn", conn);
		} catch(Throwable e) {
			throw new ServletException(e);
		}
	}
	
	@Override
	public void destroy() {
		System.out.println("AppInitServlet 마무리...");
		super.destroy();
		Connection conn = 
				(Connection)this.getServletContext().getAttribute("conn"); 
		try {
			if (conn != null && conn.isClosed() == false) {
				conn.close();
			}
		} catch (Exception e) {}
		
	}
}
```

* `sc.setAttribute("conn", conn);`: 데이터베이스 커넥션 객체를 보관소에 저장해서 모든 웹 애플리케이션에서 사용가능하도록 처리

```xml
	<!-- 서블릿 선언 -->
	<servlet>
    <servlet-name>AppInitServlet</servlet-name>
    <servlet-class>spms.servlets.AppInitServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
```

* `<load-on-startup>`: 클라이언트 요청이 없더라도 웹 애플리케이션이 시작되면 자동으로 실행

#### HttpSession

: 클라이언트의 최초 요청 시 생성되어 브라우저를 닫을 때까지 유지, 보통 로그인할 때 생성하고 로그아웃하면 비운다.

* session 변수를 통해 참조

```java
@WebServlet("/auth/login")
public class LogInServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		RequestDispatcher rd = request.getRequestDispatcher(
				"/auth/LogInForm.jsp");
		rd.forward(request, response);
	}
	
	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			ServletContext sc = this.getServletContext();
			conn = (Connection) sc.getAttribute("conn");  
			stmt = conn.prepareStatement(
					"SELECT MNAME,EMAIL FROM MEMBERS"
					+ " WHERE EMAIL=? AND PWD=?");
			stmt.setString(1, request.getParameter("email"));
			stmt.setString(2, request.getParameter("password"));
			rs = stmt.executeQuery();
			if (rs.next()) {
				Member member = new Member()
						.setEmail(rs.getString("EMAIL"))
						.setName(rs.getString("MNAME"));
				HttpSession session = request.getSession();
				session.setAttribute("member", member);
				
				response.sendRedirect("../member/list");
			} else {
				RequestDispatcher rd = request.getRequestDispatcher(
						"/auth/LogInFail.jsp");
				rd.forward(request, response);
			}
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch (Exception e) {}
			try {if (stmt != null) stmt.close();} catch (Exception e) {}
		}
	}
}
```

* 로그인 성공일 경우 Member 객체를 HttpSession에 보관한다.

```jsp
<%@page import="spms.vo.Member"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
Member member = (Member)session.getAttribute("member");
%>
<div style="background-color:#00008b;color:#ffffff;height:20px;padding: 5px;">
SPMS(Simple Project Management System)
<span style="float:right;">
<%=member.getName()%>
<a style="color:white;" 
  href="<%=request.getContextPath()%>/auth/logout">로그아웃</a>
</span>
</div>
```

* JSP 내장 객체 session을 사용하여 member라는 키로 저장된 값을 꺼낸다.

```java
@WebServlet("/auth/logout")
public class LogOutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		session.invalidate();
		
		response.sendRedirect("login");
	}
}
```

* `session.invalidate();`: 세션 객체 무효화한다.

#### ServletRequest

: 클라이언트의 요청이 들어올 때 생성되어, 클라이언트에게 응답할 때까지 유지, 보통 포워딩이나 인클루딩하는 서블릿들 사이에서 값을 공유한다.

* request 변수를 통해 참조

```java
// 생략
	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		RequestDispatcher rd = request.getRequestDispatcher(
				"/auth/LogInForm.jsp");
		rd.forward(request, response);
	}
// 생략
```

#### JspContext의 활용

: JSP 페이지를 실행하는 동안만 유지

* pageContext 변수를 통해 참조

```jsp
<body>
<jsp:include page="/Header.jsp"/>
<h1>회원목록</h1>
```

* 태그 핸들러를 사용하기 위해 필요하다.

### JSP 액션 태그

`<jsp:useBean>`: 보관소에서 자바 인스턴스를 꺼내거나, 자바 인스턴스를 새로 만들어 보관소에 저장하는 코드를 생성한다. 자바 인스턴스를 자바빈(JavaBean)이라고 한다.

```jsp
<jsp:useBean id="members"
  scope="request"
  class="java.util.ArrayList" 
  type="java.util.ArrayList<spms.vo.Member>"/>
<jsp:useBean id="member"
  scope="session"
  class="spms.vo.Member"/>
```

* scope: 보관소를 의미, request일 경우 servletRequest 보관소
* type: 참조변수를 선언할 타입의 이름

`<jsp:setProperty>`: 자바 빈의 프로퍼티 값을 설정, 자바 객체의 setter 메서드를 호출하는 코드 생성

`<jsp:getProperty>`: 자바 빈의 프로퍼티 값을 꺼냄, 자바 객체의 getter 메서드를 호출하는 코드 생성

`<jsp:param>`: `<jsp:include>`,`<jsp:forward>`의 자식 태그로 사용할 수 있음, ServletRequest  객체에 매개변수를 추가하는 코드를 생성

### EL(Expression Language)

`${객체이름.프로퍼티}` 또는 `${객체이름["프로퍼티"]}`

> `${member.no}`, `${member["no"]}`

* EL을 사용할 경우 `<jsp:useBean>` 액션 태그를 사용할 필요도 없으며 `<%=member.getNo()%>` 보다 간결하다.

* EL안에서 값, 연산 모두 가능

```jsp
${"테스트"} // 테스트
${1} // 1
${1+1} // 2
번호: <input type='text' name='no' value='${member.no}' readonly><br>
이름: <input type='text' name='name' value='${member.name}'><br>
이메일: <input type='text' name='email' value='${member.email}'><br>
가입일: ${member.createdDate}<br>
```

### JSTL(Java Standard Tab Library)

태그 라이브러리 선언: `<%@ tablib uri="사용할 태그의 라이브러리 URI" prefix="접두사" %>`

| 태그 라이브러리 | 접두사 | 네임스페이스의 URI 식별자               |
| --------------- | ------ | --------------------------------------- |
| Core            | c      | http://java.sun.com/jsp/jstl/core       |
| XML             | x      | http://java.sun.com/jsp/jstl/xml        |
| \|18N           | fmt    | http://java.sun.com/jsp/jstl/fmt        |
| Database        | sql    | http://java.sun.com/jsp/jstl/sql        |
| Functions       | fn     | http://java. sun.com/jsp/jstl/functions |

* `<c:out value="출력할 값">기본값</c:out>`

* `<c:set value="값" target="${객체}" property="propertyName" scope="request" var="변수 명" />`
* `<c:if>`: 조건
* `<c:choose>`: switch case문
* `<c:forEach>`: 반복
* `<c:forTokens>`: 문자열을 특정 구분자로 분리하여 반복문을 돌림
* `<c:url>`: url 생성

나머진 JSP.md 파일에서 찾거나 구글링

```jsp
<!-- <%@page import="spms.vo.Member"%> -->
<!-- <%@page import="java.util.ArrayList"%> -->

<%@ page 
  language="java" 
  contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>      
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>회원 목록</title>
</head>
<body>
<jsp:include page="/Header.jsp"/>
<h1>회원목록</h1>
<p><a href='add.do'>신규 회원</a></p>
<!-- <jsp:useBean id="members"
  scope="request"
  class="java.util.ArrayList" 
  type="java.util.ArrayList<spms.vo.Member>"/> -->
<c:forEach var="member" items="${members}"> 
${member.no},
<a href='update.do?no=${member.no}'>${member.name}</a>,
${member.email},
${member.createdDate}
<a href='delete.do?no=${member.no}'>[삭제]</a><br>
</c:forEach>
<jsp:include page="/Tail.jsp"/>
</body>
</html>
```

### DAO(Data Acess Object) 분리

: 데이터베이스와 연동하여 데이터를 처리하는 부분을 분리

> MemberDAO.java

```java
// 생략
public class MemberDao {
  Connection connection;

  public void setConnection(Connection connection) {
    this.connection = connection;
  }

  public List<Member> selectList() throws Exception {
    Statement stmt = null;
    ResultSet rs = null;

    try {
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
    }
  }
}
// 생략
```

* selectList() 리턴 타입이 `List` 이다.

* ```java
    Connection connection;
    
    public void setConnection(Connection connection) {
      this.connection = connection;
    }
  ```

  * 작업에 필요한 객체를 외부로부터 주입 받는 것을 '의존성 주입(DI)' 또는 '역제여(IoC, Invension of Control)'이라고 부른다.

> MemberListServlet.java

```java
// MemberDao 사용  
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			ServletContext sc = this.getServletContext();
			Connection conn = (Connection) sc.getAttribute("conn"); 
			
			MemberDao memberDao = new MemberDao();
			memberDao.setConnection(conn);
			
			request.setAttribute("members", memberDao.selectList());
			
			response.setContentType("text/html; charset=UTF-8");
			RequestDispatcher rd = request.getRequestDispatcher(
					"/member/MemberList.jsp");
			rd.include(request, response);
			
		} catch (Exception e) {
			e.printStackTrace();
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
			rd.forward(request, response);
		}
	}
}
```

* MemberListServlet 클래스에는 데이터베이스와 관련된 코드가 존재하지 않고 MemberDAO로 이관됨

### 리스너

서블릿 컨테이너는 웹 애플리케이션의 상태를 모니터링 할 수 있도록 웹 애플리케이션 시작에서 종료까지 주요한 사건에 대해 알림 기능을 제공한다. 이런 알림 기능을 이용하고 싶다면, 규칙에 따라 객체를 만들어 DD파일(web.xml)에 등록하면 되고 이렇게 사건이 발생했을 때 알림을 받는 객체릴 '리스너(Listener)'라고 부른다.

#### ServletContextListener

: 웹 애플리케이션이 시작하거나 종료할 때 이벤트

* 웹 애플리케이션이 시작, 종료할 때 DAO 객체를 준비하여 ServletContext에 저장한다.

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  Connection conn;
  
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      Class.forName(sc.getInitParameter("driver"));
      conn = DriverManager.getConnection(
          sc.getInitParameter("url"),
          sc.getInitParameter("username"),
          sc.getInitParameter("password"));

      MemberDao memberDao = new MemberDao();
      memberDao.setConnection(conn);

      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    try {
      conn.close();
    } catch (Exception e) {}
  }
}
```

* `contextInitialized`: 웹 애플리케이션 시작

* `contextDestroyed`: 종료

* `Connection conn = (Connection) sc.getAttribute("conn"); ` -> 제거

* ```java
  ServletContext sc = this.getServletContext();
  // Connection conn = (Connection) sc.getAttribute("conn"); 
  
  // MemberDao memberDao = new MemberDao();
  // memberDao.setConnection(conn);
  MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");
  ```

### DB 커넥션풀

: DB 커넥션 객체를 여러 개 생성하여 pool에 담에 놓고 필요할 때 꺼내 쓰는 방식

* 어떤 요청을 처리하다가 예외가 발생하여 롤백한다면, 다른요청에대해 작업한 내역까지 롤백되는 문제가 발생하므로 각 요청에 대해 별도의 커넥션 객체를 사용하기 때문에 다른 작업에 영향을 주지 않는다.
* 사용한 DB커넥션 객체는 버리지 않고 풀에 보관 후 사용하므로 가비지가 생성되지 않고 속도도 빨라진다.

```java
public class DBConnectionPool {
  String url;
  String username;
  String password;
  ArrayList<Connection> connList = new ArrayList<Connection>();
  
  // 생성자는 DB 커텍션 생성에 필요한 값을 매개변수로 받는다.
  public DBConnectionPool(String driver, String url, 
      String username, String password) throws Exception {
    this.url = url;
    this.username = username;
    this.password = password;
    
    Class.forName(driver);
  }
  
  public Connection getConnection() throws Exception {
    if (connList.size() > 0) {
      Connection conn = connList.remove(0); 
      if (conn.isValid(10)) {
        // 유효성 체크 후 반환
        return conn;
      }
    }
    return DriverManager.getConnection(url, username, password); 
    // ArrayList에 보관된 객체가 없다면, DriverManager를 통해 새로만들어 반환
  }
    
  // 커넥션 객체를 쓰고 난 다음에는 이 메서드를 호출하여 커텍션 풀에 반환하여 다시 사용
  public void returnConnection(Connection conn) throws Exception {
    connList.add(conn);
  }
  
  // 웹 애플리케이션이 종료하기 전에 이 메서드를 호출하여 데이터베이스와 연결된 것을 모두 끊어야함
  public void closeAll() {
    for(Connection conn : connList) {
      try{conn.close();} catch (Exception e) {}
    }
  }
}
```

> MemberDAO.java

```java
// 생략
public class MemberDao {
  // Connection connection;

  // public void setConnection(Connection connection) {
  //  this.connection = connection;
  // }
    
  DBConnectionPool connPool;

  public void setDbConnectionPool(DBConnectionPool connPool) {
    this.connPool = connPool;
  }

  public List<Member> selectList() throws Exception {
    Statement stmt = null;
    ResultSet rs = null;

    try {
      connection = connPool.getConnection(); 
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
      if (connection != null) connPool.returnConnection(connection);
    }
  }
}
// 생략
```

* `DBConnectionPool connPool;`: 추가
* `connection = connPool.getConnection(); `: 추가

* `if (connection != null) connPool.returnConnection(connection);`: 추가

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
//  Connection conn;
  DBConnectionPool connPool;
    
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      //Class.forName(sc.getInitParameter("driver"));
      //conn = DriverManager.getConnection(
      //    sc.getInitParameter("url"),
      //    sc.getInitParameter("username"),
      //    sc.getInitParameter("password"));

      connPool = new DBConnectionPool(
          sc.getInitParameter("driver"),
          sc.getInitParameter("url"),
          sc.getInitParameter("username"),
          sc.getInitParameter("password"));
        
        
      MemberDao memberDao = new MemberDao();
      //memberDao.setConnection(conn);
      memberDao.setDbConnectionPool(connPool);
      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    //try {
    //  conn.close();
    //} catch (Exception e) {}
    connPool.closeAll();
  }
}
```

* `memberDao.setDbConnectionPool(connPool);`: MemberDAO 객체를 생성할 때 커넥션풀 객체를 주입한다.

### DataSource와 JNDI

#### DataSource

: DriverManager를 통해 DB커넥션을 얻는 것보다 좋은 기능을 제공한다.

* 서버에서 관리하기 때문에 데이터베으산 JDBC 드라이버가 변경되더라도 애플리케이션을 바꿀 필요가 없다.
* Connection과 Statement 객체를 풀링할 수 있으며, 분산 트랜젝션을 다룰 수 있다.

> ContextLoaderListener.java

```java
// Apache DBCP 적용

@WebListener
public class ContextLoaderListener implements ServletContextListener {
  BasicDataSource ds;
  
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      ds = new BasicDataSource();
      ds.setDriverClassName(sc.getInitParameter("driver"));
      ds.setUrl(sc.getInitParameter("url"));
      ds.setUsername(sc.getInitParameter("username"));
      ds.setPassword(sc.getInitParameter("password"));
      
      MemberDao memberDao = new MemberDao();
      memberDao.setDataSource(ds);
      
      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    try { if (ds != null) ds.close(); } catch (SQLException e) {}
  }
}
```

* `BasicDataSource ds;`: 아파치 DBCP 라이브러리에서 DataSource 인터페이스를 구현한 BasicDataSource 클래스의 인스턴스 변수를 선언
* `ds = new BasicDataSource();`: BasicDataSource 객체를 생성
* `memberDao.setDataSource(ds);`: MemberDAO에 주입

>MemberDao.java

```java
// 생략
public class MemberDao {    
//  DBConnectionPool connPool;
  DataSource ds;
    
//  public void setDbConnectionPool(DBConnectionPool connPool) {
//    this.connPool = connPool;
//  }

  public void setDataSource(DataSource ds) {
    this.ds = ds;
  }
    
  public List<Member> selectList() throws Exception {
    Connection connection = null;
    Statement stmt = null;
    ResultSet rs = null;

    try {
//      connection = connPool.getConnection(); 
      connection = ds.getConnection();
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
      //if (connection != null) connPool.returnConnection(connection);
      try {if (connection != null) connection.close();} catch(Exception e) {}
    }
  }
}
// 생략
```

#### 서버에서 DataSource 사용

> context.xml

```xml
	<Resource name="jdbc/studydb" auth="Container" type="javax.sql.DataSource"
	    maxActive="10" maxIdle="3" maxWait="10000" 
	    username="study"
	    password="study" 
	    driverClassName="com.mysql.jdbc.Driver"
	    url="jdbc:mysql://localhost/studydb" 
	    closeMethod="close"/>
```

* `name="jdbc/studydb"`: JNDI이름, java:comp/env 디렉터리에서 찾을 수 있다.

> web.xml

```xml
<resource-ref>
	<res-ref-name>jdbc/studydb</res-ref-name>
	<res-type>javax.sql.DataSource</res-type>
	<res-auth>Contrainer</res-auth>
</resource-ref>
```

* `<res-ref-name>JNDI 이름</res-ref-name>`
* `<res-type>리턴될 자원의 클래스 이름(패키지명 포함)</res-type>`
* `<res-auth>자원 관리의 주체</res-auth>`: Contrainer는 서버에서 관리한다는 의미

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
//  BasicDataSource ds;
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      InitialContext initialContext = new InitialContext();
      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
      MemberDao memberDao = new MemberDao();
      memberDao.setDataSource(ds);
      
      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* `InitialContext initialContext = new InitialContext();`: BasicDataSource를 직접 사용하지 않으므로 톰캣에서 자원을 찾기 위해 InitialContext 객체를 생성
* `DataSource ds = (DataSource)initialContext.lookup("java:comp/env/jdbc/studydb");`
  * JNDI 이름으로 등록되어 있는 서버 자원을 찾기 위해 lookup 메서드 이용

## 제 6장 미니 MVC 프레임워크 만들기

기존의 1개의 컨트롤러에서 프런트 컨트롤러와 페이지 컨트롤러로 분리

프런트 컨트롤러: VO 객체의 준비, 뷰 컴포넌트로 위임, 오류 처리 등과 같은 공동작업

페이지 컨트롤러: 이름 그대로 요청한 페이지만을 위한 작업을 수행

> DispatcherServlet.java

```java
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      String pageControllerPath = null;
      
      if ("/member/list.do".equals(servletPath)) {
        pageControllerPath = "/member/list";
      } else if ("/member/add.do".equals(servletPath)) {
        pageControllerPath = "/member/add";
        if (request.getParameter("email") != null) {
          request.setAttribute("member", new Member()
            .setEmail(request.getParameter("email"))
            .setPassword(request.getParameter("password"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/update.do".equals(servletPath)) {
        pageControllerPath = "/member/update";
        if (request.getParameter("email") != null) {
          request.setAttribute("member", new Member()
            .setNo(Integer.parseInt(request.getParameter("no")))
            .setEmail(request.getParameter("email"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/delete.do".equals(servletPath)) {
        pageControllerPath = "/member/delete";
      } else if ("/auth/login.do".equals(servletPath)) {
        pageControllerPath = "/auth/login";
      } else if ("/auth/logout.do".equals(servletPath)) {
        pageControllerPath = "/auth/logout";
      }
      
      RequestDispatcher rd = request.getRequestDispatcher(pageControllerPath);
      rd.include(request, response);
      
      String viewUrl = (String) request.getAttribute("viewUrl");
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
        
      } else {
        rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
}
```

> MemberListServlet.java

```java
// 프런트 컨트롤러 적용  
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;

  @Override
  public void doGet(
      HttpServletRequest request, HttpServletResponse response)
          throws ServletException, IOException {
    try {
      ServletContext sc = this.getServletContext();
      MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");

      request.setAttribute("members", memberDao.selectList());

//	request.setAttribute("members", memberDao.selectList());
			
//	response.setContentType("text/html; charset=UTF-8");
//	RequestDispatcher rd = request.getRequestDispatcher(
//			"/member/MemberList.jsp");
//	rd.include(request, response);
        
      request.setAttribute("viewUrl", "/member/MemberList.jsp");
    } catch (Exception e) {
      throw new ServletException(e);
//	e.printStackTrace();
//	request.setAttribute("error", e);
//	RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
//	rd.forward(request, response);
    }
  }
}
```

> MemberAddServlet.java

```java
// 프런트 컨트롤러 적용  
@WebServlet("/member/add")
public class MemberAddServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;

  @Override
  protected void doGet(
      HttpServletRequest request, HttpServletResponse response)
          throws ServletException, IOException {
    request.setAttribute("viewUrl", "/member/MemberForm.jsp");
  }

  @Override
  protected void doPost(
      HttpServletRequest request, HttpServletResponse response)
          throws ServletException, IOException {
    try {
      ServletContext sc = this.getServletContext();
      MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");
      
      Member member = (Member)request.getAttribute("member");
      memberDao.insert(member);
      
      request.setAttribute("viewUrl", "redirect:list.do");

    } catch (Exception e) {
      throw new ServletException(e);
    }
  }
}
```

* *.do 요청 -> DispatcherServlet(프론트 컨트롤러) -> MemberListServlet(페이지 컨트롤러), MemberAddServlet(페이지 컨트롤러)

### 페이지 컨트롤러의 진화

: 페이지 컨트롤러를 servlet에서 일반 클래스로 전환

> Controller.java

```java
package spms.controls;

import java.util.Map;

public interface Controller {
  String execute(Map<String, Object> model) throws Exception;
}
```

* `execute()`: 페이지 컨트롤러에게 일을 시키기 위한 메서드, 프런트 컨트롤러가 excute() 를 호출하려면 Map 객체를 매개변수로 넘겨줘야 한다.

> MemberListController.java

```java
public class MemberListController implements Controller {
  @Override
  public String execute(Map<String, Object> model) throws Exception {
    // Map(model) 객체에서 MemberDao를 꺼낸다.
    MemberDao memberDao = (MemberDao)model.get("memberDao");
    
    // 회원 목록 데이터를 Map 객체에 저장한다.
    model.put("members", memberDao.selectList());
    
    // 화면을 출력할 페이지의 URL을 반환한다.
    return "/member/MemberList.jsp";
  }
}
```

> DispatcherServlet.java

```java
// Controller 규칙에 따라 페이지 컨트롤러를 호출
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      ServletContext sc = this.getServletContext();
      
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
      model.put("memberDao", sc.getAttribute("memberDao"));
      model.put("session", request.getSession());
      
      Controller pageController = null;
      
      if ("/member/list.do".equals(servletPath)) {
        pageController = new MemberListController();
      } else if ("/member/add.do".equals(servletPath)) {
        pageController = new MemberAddController();
        if (request.getParameter("email") != null) {
          model.put("member", new Member()
            .setEmail(request.getParameter("email"))
            .setPassword(request.getParameter("password"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/update.do".equals(servletPath)) {
// 생략
      } else if ("/member/delete.do".equals(servletPath)) {
        pageController = new MemberDeleteController();
        model.put("no", new Integer(request.getParameter("no")));
      } else if ("/auth/login.do".equals(servletPath)) {
// 생략
      } else if ("/auth/logout.do".equals(servletPath)) {
        pageController = new LogOutController();
      }
      
      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
      
      // Map 객체에 저장된 값을 ServletRequest에 복사한다.
      for (String key : model.keySet()) {
        request.setAttribute(key, model.get(key));
      }
      
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
      } else {
        RequestDispatcher rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
}
```

* `model.put("memberDao", sc.getAttribute("memberDao"));`: ServletContext에 담긴 MemberDao 객체를 꺼내서 Map 객체에 담음
* `String viewUrl = pageController.execute(model);`: excute 반환값은 화면 출력을 수행하는 JSP의 URL
* `request.setAttribute(key, model.get(key));`: 페이지 컨트롤러의 실행이 끝난 다음, Map 객체에 보관되어 있는 데이터나 객체를 JSP가 사용할 수 있도록 ServletRequset에 복사

> MemberAddController.java

```java
public class MemberAddController implements Controller {
  @Override
  public String execute(Map<String, Object> model) throws Exception {
    if (model.get("member") == null) { // 입력폼을 요청할 때
      return "/member/MemberForm.jsp";
      
    } else { // 회원 등록을 요청할 때
      MemberDao memberDao = (MemberDao)model.get("memberDao");
      
      Member member = (Member)model.get("member");
      memberDao.insert(member);
      
      return "redirect:list.do";
    }
  }
}
```

* `if (model.get("member") == null) {`: Map 객체에 Member 인스턴스가 없을 경우



### DI를 이용한 빈 의존성 관리

데이터베이스로부터 회원 정보를 가져다줄 MemberDao와 같이 특정 작업을 수행할 때 사용하는 객체를 '의존객체'라고 한다.

* 의존 객체를 미리 생성 후 사용

```java
    MemberDao memberDao = (MemberDao)model.get("memberDao");
    model.put("members", memberDao.selectList());
    return "/member/MemberList.jsp";
```

의존 객체를 직접 생성하거나 보관소에서 꺼내는 방식으로 관리하면 결합도 증가에 따른 문제가 발생한다.

1. 의존 객체 사용과 의존 객체 변경이 발생하면 바로 영향을 받는다.
2. 데이터베이스가 바뀔 때마다 DAO를 사용하는 코드도 변경해야한다.
   * MySQL -> Oracle

#### 외부에서 주입(DI)

> MemberListController.java

```java
// 의존 객체 주입을 위해 인스턴스 변수와 셋터 메서드 추가
//- 또한 의존 객체를 꺼내는 기존 코드 변경
public class MemberListController implements Controller {
  MemberDao memberDao;
  
  public MemberListController setMemberDao(MemberDao memberDao) {
    this.memberDao = memberDao;
    return this;
  }

  @Override
  public String execute(Map<String, Object> model) throws Exception {
    model.put("members", memberDao.selectList());
    return "/member/MemberList.jsp";
  }
}
```

> ContextLoaderListener.java

```java
// 페이지 컨트롤러 객체 준비
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      InitialContext initialContext = new InitialContext();
      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
      MemberDao memberDao = new MemberDao();
      memberDao.setDataSource(ds);

//      sc.setAttribute("memberDao", memberDao);
        
      sc.setAttribute("/auth/login.do", 
          new LogInController().setMemberDao(memberDao));
      sc.setAttribute("/auth/logout.do", new LogOutController());
      sc.setAttribute("/member/list.do", 
          new MemberListController().setMemberDao(memberDao));
      sc.setAttribute("/member/add.do", 
          new MemberAddController().setMemberDao(memberDao));
      sc.setAttribute("/member/update.do", 
          new MemberUpdateController().setMemberDao(memberDao));
      sc.setAttribute("/member/delete.do", 
          new MemberDeleteController().setMemberDao(memberDao));
      
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* `sc.setAttribute("memberDao", memberDao);`: memberDao를 별도로 꺼내서 사용할 일이 없기 때문에 ServletContext에 저장하지 않는다.
* `sc.setAttribute("/auth/login.do", new LogInController().setMemberDao(memberDao));`: 페이지 컨트롤러 객체를 생성하고 나서 MemberDAO가 필요한 객체에 대해서는 셋터 메서드를 호출하여 주입한다. 이렇게 생성된 페이지 컨트롤러를 SertvletContext에 저장한다.

> DispatcherServlet.java

```java
// ServletContext에 보관된 페이지 컨트롤러를 사용
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      ServletContext sc = this.getServletContext();
      
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
//      model.put("memberDao", sc.getAttribute("memberDao"));
        model.put("session", request.getSession());
      
      Controller pageController = (Controller) sc.getAttribute(servletPath);
      
      if ("/member/add.do".equals(servletPath)) {
        if (request.getParameter("email") != null) {
          model.put("member", new Member()
            .setEmail(request.getParameter("email"))
            .setPassword(request.getParameter("password"))
            .setName(request.getParameter("name")));
        }
      } else if ("/member/update.do".equals(servletPath)) {
// 생략
      }
      
      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
      
      // Map 객체에 저장된 값을 ServletRequest에 복사한다.
      for (String key : model.keySet()) {
        request.setAttribute(key, model.get(key));
      }
      
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
      } else {
        RequestDispatcher rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
}
```

* `model.put("memberDao", sc.getAttribute("memberDao"));`: MemberDao 객체는 Map 객체에 담을 필요 없어 제거
* `Controller pageController = (Controller) sc.getAttribute(servletPath);`: 페이지 컨트롤러는 ServletContext 보관소에 저장되어 있으며 이 보관소에서 페이지 컨트롤러를 꺼낼 때는 서블릿 URL을 사용

#### 인터페이스를 활용하여 MemberDao 정의

: 각 데이터베이스에 맞춰 DAO클래스를 준비하지 않고 인터페이스를 활용하여 DAO가 갖춰야 할 규격을 정의하고, 그 규격을 준수하는 클래스라면 어떤 클래스를 상속받았는지 따지지 않고 허용한다.

> MemberDao -> MySqlMemberDao

```java
// MemberDao 인터페이스 정의 
import java.util.List;

import spms.vo.Member;

public interface MemberDao {
  List<Member> selectList() throws Exception;
  int insert(Member member) throws Exception;
  int delete(int no) throws Exception;
  Member selectOne(int no) throws Exception;
  int update(Member member) throws Exception;
  Member exist(String email, String password) throws Exception;
}
```

```java
// MemberDao 인터페이스 구현 
public class MySqlMemberDao implements MemberDao {
  // 생략
}

```

> ContextLoaderListener

```java
// MySqlMemberDao 적용
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();
      
      InitialContext initialContext = new InitialContext();
      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
//    MemberDao memberDao = new MemberDao();
      MySqlMemberDao memberDao = new MySqlMemberDao();
      memberDao.setDataSource(ds);

// 생략
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

### 리플랙션 API를 이용하여 프런트 컨트롤러 개선하기

인스턴스 자동 생성 + 메서드 자동으로 호출

> DataBinding.java

```java
public interface DataBinding {
  Object[] getDataBinders();
}
```

* 페이지 컨트롤러 중에서 클라이언트가 보낸 데이터가 필요한 경우 이 DataBinding 인터페이스를 구현한다.

>MemberAddController.java

```java
// Map 객체에 저장할 파라미터에 대한 정보 제공
// - DataBinding 인터페이스 구현
public class MemberAddController implements Controller, DataBinding {
  MemberDao memberDao;
  
  public MemberAddController setMemberDao(MemberDao memberDao) {
    this.memberDao = memberDao;
    return this;
  }
  
  public Object[] getDataBinders() {
    return new Object[]{
        "member", spms.vo.Member.class
    };
  }
  
  @Override
  public String execute(Map<String, Object> model) throws Exception {
    Member member = (Member)model.get("member");
    if (member.getEmail() == null) { // 입력폼을 요청할 때
      return "/member/MemberForm.jsp";
    } else { // 회원 등록을 요청할 때
      memberDao.insert(member);
      return "redirect:list.do";
    }
  }
}
```

* `new Object[]{"member", spms.vo.Member.class};`: 클라이언트가 보낸 매개변수 값을 Member 인스턴스에 담아서 "member"라는 이름으로 map 객체에 저장해 달라는 의미

> DispatcherServlet.java

```java
// ServletContext에 보관된 페이지 컨트롤러를 사용
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
      ServletContext sc = this.getServletContext();
      
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
      model.put("session", request.getSession());
      
      Controller pageController = (Controller) sc.getAttribute(servletPath);

      if (pageController instanceof DataBinding) {
        prepareRequestData(request, model, (DataBinding)pageController);
      }

//      if ("/member/add.do".equals(servletPath)) {
//        if (request.getParameter("email") != null) {
//          model.put("member", new Member()
//            .setEmail(request.getParameter("email"))
//            .setPassword(request.getParameter("password"))
//            .setName(request.getParameter("name")));
//        }
//      } else if ("/member/update.do".equals(servletPath)) {
          // 생략
//      }
      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
      
      // Map 객체에 저장된 값을 ServletRequest에 복사한다.
      for (String key : model.keySet()) {
        request.setAttribute(key, model.get(key));
      }
      
      if (viewUrl.startsWith("redirect:")) {
        response.sendRedirect(viewUrl.substring(9));
        return;
      } else {
        RequestDispatcher rd = request.getRequestDispatcher(viewUrl);
        rd.include(request, response);
      }
      
    } catch (Exception e) {
      e.printStackTrace();
      request.setAttribute("error", e);
      RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
      rd.forward(request, response);
    }
  }
  private void prepareRequestData(HttpServletRequest request,
      HashMap<String, Object> model, DataBinding dataBinding)
      throws Exception {
    Object[] dataBinders = dataBinding.getDataBinders();
    String dataName = null;
    Class<?> dataType = null;
    Object dataObj = null;
    for (int i = 0; i < dataBinders.length; i+=2) {
      dataName = (String)dataBinders[i];
      dataType = (Class<?>) dataBinders[i+1];
      dataObj = ServletRequestDataBinder.bind(request, dataType, dataName);
      model.put(dataName, dataObj);
    }
  }
}
```

* 매개변수 값을 사용하는 페이지 컨트롤러를 추가하더라도 조건문을 삽입하는 대신 데이터 준비를 자동으로 수행하는 `prepareRequestData()`를 호출한다.
* `Object[] dataBinders = dataBinding.getDataBinders();`: 페이지 컨트롤러에게 필요한 데이터가 무엇인지 묻는다.
* `dataObj = ServletRequestDataBinder.bind(request, dataType, dataName);`: bind() 메서드는 dataName과 일치하는 요청 매개변수를 찾고 dataType을  통해 해당 클래스의 인스턴스를 생성한다. 찾은 매개변수 값을 인스턴스에 저장하며 그 인스턴스를 반환한다.

> ServletRequestDataBinder.java

```java
public class ServletRequestDataBinder {
  // DispatcherServlet에서 호출한 bind 메서드
  public static Object bind(ServletRequest request, Class<?> dataType, String dataName) throws Exception {
    // dataType이 기본타입이면 즉시 객체를 생성하여 반환
    if (isPrimitiveType(dataType)) {
      return createValueObject(dataType, request.getParameter(dataName));
    }
    
    Set<String> paramNames = request.getParameterMap().keySet();
    Object dataObject = dataType.newInstance();
    Method m = null;
    
    for (String paramName : paramNames) {
      m = findSetter(dataType, paramName);
      if (m != null) {
        m.invoke(dataObject, createValueObject(m.getParameterTypes()[0], 
            request.getParameter(paramName)));
      }
    }
    return dataObject;
  }
  // 아래 타입에 대해 기본 타입으로 간주하여 true를 반환
  private static boolean isPrimitiveType(Class<?> type) {
    if (type.getName().equals("int") || type == Integer.class ||
        type.getName().equals("long") || type == Long.class ||
        type.getName().equals("float") || type == Float.class ||
        type.getName().equals("double") || type == Double.class ||
        type.getName().equals("boolean") || type == Boolean.class ||
        type == Date.class || type == String.class) {
      return true;
    }
    return false;
  }
  // 기본 타입의 객체를 생성할 때 호출, 요청 매개변수의 값으로부터 String이나 Date 등의 기본 타입 객체를 생성한다.
  private static Object createValueObject(Class<?> type, String value) {
    if (type.getName().equals("int") || type == Integer.class) {
      return new Integer(value);
    } else if (type.getName().equals("float") || type == Float.class) {
      return new Float(value);
    } else if (type.getName().equals("double") || type == Double.class) {
      return new Double(value);
    } else if (type.getName().equals("long") || type == Long.class) {
      return new Long(value);
    } else if (type.getName().equals("boolean") || type == Boolean.class) {
      return new Boolean(value);
    } else if (type == Date.class) {
      return java.sql.Date.valueOf(value);
    } else {
      return value;
    }
  }
  // 데이터 타입(Class)과 매개변수 이름(String)을 주면 셋터 메서드를 찾아서 반환한다.
  private static Method findSetter(Class<?> type, String name) {
    Method[] methods = type.getMethods();
    
    String propName = null;
    for (Method m : methods) {
      if (!m.getName().startsWith("set")) continue;
      
      propName = m.getName().substring(3);
      if (propName.toLowerCase().equals(name.toLowerCase())) {
        return m;
      }
    }
    return null;
  }
}
```

* `ServletRequestDataBinder` 클래스는 클라이언트가 보낸 매개변수 값을 자바 객체에 담아 주는 역할을 수행한다.

### 프로퍼티를 이용한 객체 관리

DAO를 추가하는 경우에도 ContextLoaderListener 클래스에 코드 추가가 아닌, 객체를 생성하고 의존 객체를 주입하는 부분을 자동화

#### 프로퍼티 파일 작성

>/WebContent/WEB-INF/application-context.properties

```properties
#1. for ApplicationContext.
jndi.dataSource=java:comp/env/jdbc/studydb
memberDao=spms.dao.MySqlMemberDao
/auth/login.do=spms.controls.LogInController
/auth/logout.do=spms.controls.LogOutController
/member/list.do=spms.controls.MemberListController
/member/add.do=spms.controls.MemberAddController
/member/update.do=spms.controls.MemberUpdateController
/member/delete.do=spms.controls.MemberDeleteController
```

* `jndi.dataSource=java:comp/env/jdbc/studydb` = `jndi.{객체이름}={JNDI이름}`
* `memberDao=spms.dao.MySqlMemberDao` = `{객체이름}={패키지 이름을 포함한 클래스 이름}`
* `/auth/login.do=spms.controls.LogInController` = `{서블릿 URL}={패키지 이름을 포함한 클래스 이름}`

#### ApplicationContext 클래스

```java
// 프로퍼티 파일을 이용한 객체 준비
public class ApplicationContext {
  Hashtable<String,Object> objTable = new Hashtable<String,Object>();
  
  public Object getBean(String key) {
    return objTable.get(key);
  }
  
  public ApplicationContext(String propertiesPath) throws Exception {
    Properties props = new Properties();
    props.load(new FileReader(propertiesPath)); // 프로퍼티 내용을 키-값 형태로 내부 맵에 보관
    
    prepareObjects(props);
    injectDependency();
  }
  
  private void prepareObjects(Properties props) throws Exception {
    Context ctx = new InitialContext(); // JNDI 객체를 찾을 때 사용할 객체
    String key = null;
    String value = null;
    
    for (Object item : props.keySet()) {
      key = (String)item;
      value = props.getProperty(key);
      // 프로퍼티가 jndi로 시작한다면 객체를 생성하지 않고 InitialContext를 통해 얻는다
      if (key.startsWith("jndi.")) {
        objTable.put(key, ctx.lookup(value));
      } else {
// 나머지 객체는 Class.forName()을 호출하여 클래스를 로딩하고, newInstance()를 사용하여 인스턴스를 생성한다.
        objTable.put(key, Class.forName(value).newInstance());
      }
    }
  }
  
  private void injectDependency() throws Exception {
    for (String key : objTable.keySet()) {
      if (!key.startsWith("jndi.")) {
        callSetter(objTable.get(key));
      }
    }
  }

  private void callSetter(Object obj) throws Exception {
    Object dependency = null;
    for (Method m : obj.getClass().getMethods()) {
      if (m.getName().startsWith("set")) {
        dependency = findObjectByType(m.getParameterTypes()[0]);
        if (dependency != null) {
          m.invoke(obj, dependency);
        }
      }
    }
  }
  
  private Object findObjectByType(Class<?> type) {
    for (Object obj : objTable.values()) {
      if (type.isInstance(obj)) {
        return obj;
      }
    }
    return null;
  }
}
```

#### ContextLoaderListener 변경

```java
// 프로퍼티 파일 적용 : ApplicationContext 사용
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  static ApplicationContext applicationContext;

  public static ApplicationContext getApplicationContext() {
    return applicationContext;
  }
    
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      String propertiesPath = sc.getRealPath(
          sc.getInitParameter("contextConfigLocation"));
      applicationContext = new ApplicationContext(propertiesPath);
//      InitialContext initialContext = new InitialContext();
//      DataSource ds = (DataSource)initialContext.lookup(
          "java:comp/env/jdbc/studydb");
      
//      MySqlMemberDao memberDao = new MySqlMemberDao();
//      memberDao.setDataSource(ds);
      
//      sc.setAttribute("/auth/login.do", 
//          new LogInController().setMemberDao(memberDao));
//      sc.setAttribute("/auth/logout.do", new LogOutController());
//      sc.setAttribute("/member/list.do", 
//          new MemberListController().setMemberDao(memberDao));
//      sc.setAttribute("/member/add.do", 
//          new MemberAddController().setMemberDao(memberDao));
//      sc.setAttribute("/member/update.do", 
//          new MemberUpdateController().setMemberDao(memberDao));
//      sc.setAttribute("/member/delete.do", 
//          new MemberDeleteController().setMemberDao(memberDao));
      
    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {}
}
```

* 페이지 컨트롤러나 DAO 등을 추가할 때는 프로퍼티 파일에 그 클래스에 대한 정보를 한 줄 추가하면 자동으로 그 객체가 생성된다.

#### web.xml 파일에 프로퍼티 경로 정보 설정

```xml
  <!-- 컨텍스트 초기화 파라미터 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/application-context.properties</param-value>
  </context-param>
  <resource-ref>
      <res-ref-name>jdbc/studydb</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
  </resource-ref>
```

#### DispatcherServlet 변경

```java
// ServletContext에 보관된 페이지 컨트롤러를 사용
@SuppressWarnings("serial")
@WebServlet("*.do")
public class DispatcherServlet extends HttpServlet {
  @Override
  protected void service(
      HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    response.setContentType("text/html; charset=UTF-8");
    String servletPath = request.getServletPath();
    try {
//      ServletContext sc = this.getServletContext();
      ApplicationContext ctx = ContextLoaderListener.getApplicationContext();
        
      // 페이지 컨트롤러에게 전달할 Map 객체를 준비한다. 
      HashMap<String,Object> model = new HashMap<String,Object>();
      model.put("session", request.getSession());
      
//      Controller pageController = (Controller) sc.getAttribute(servletPath);
      Controller pageController = (Controller) ctx.getBean(servletPath);
      if (pageController == null) {
        throw new Exception("요청한 서비스를 찾을 수 없습니다.");
      }
        
      if (pageController instanceof DataBinding) {
        prepareRequestData(request, model, (DataBinding)pageController);
      }

      // 페이지 컨트롤러를 실행한다.
      String viewUrl = pageController.execute(model);
// 생략
```

* 이전에는 페이지 컨트롤러가 ServletContext에 저장되었기 때문에 이 객체를 준비해야 했지만, ApplicationContext를 도입하면서 필요 없어져서 제거
* ContextLoaderListener의 getApplicationContext()를 호출하여 ApplicationContext 객체를 꺼냄
* 페이지 컨트롤러를 찾을 때도 ServletContext에서 찾지 않기 때문에 제거
* ApplicationContext의 getBean()메서드를 호출하여 페이지 컨트롤러를 찾고 찾지 못하면 오류 발생 시킴

### 애노테이션을 이용한 객체 관리

프로퍼티 추가 대신 애노테이션을 통해 관리

> Component.java

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {
  String value() default "";
}
```

* 애노테이션 유지 정책을 RUNTIME으로 했으므로, 실행 중에도 언제든 @Component 애노테이션을 속성값으로 참조할 수 있다.

> MySqlMemberDao.java

```java
@Component("memberDao")
public class MySqlMemberDao implements MemberDao {
  DataSource ds;
    // 생략
```

> /WebContent/WEB-INF/application-context.properties

```properties
# using Annotation
jndi.dataSource=java:comp/env/jdbc/studydb
```



#### ApplicationContext 변경

```java
// 프로퍼티 파일 및 애노테이션을 이용한 객체 준비
public class ApplicationContext {
  Hashtable<String,Object> objTable = new Hashtable<String,Object>();
  
  public Object getBean(String key) {
    return objTable.get(key);
  }
  
  public ApplicationContext(String propertiesPath) throws Exception {
    Properties props = new Properties();
    props.load(new FileReader(propertiesPath));
    
    prepareObjects(props);
    prepareAnnotationObjects(); // 추가
    injectDependency();
  }
  
  // 추가
  private void prepareAnnotationObjects() throws Exception{
    Reflections reflector = new Reflections("");
    
    Set<Class<?>> list = reflector.getTypesAnnotatedWith(Component.class);
    String key = null;
    for(Class<?> clazz : list) {
      key = clazz.getAnnotation(Component.class).value();
      objTable.put(key, clazz.newInstance());
    }
  }
// 생략
```

* 애노테이션이 붙은 클래스를 찾아서 객체를 준비하는 것이 추가됨

* `prepareAnnotationObjects()`: 자바 classpath를 뒤져서 @Component 애노테이션이 붙은 클래스를 찾아 객체를 생성하여 객체 테이블에 담는 역할을 한다.
* `Reflections`클래스는 원하는 클래스를 찾아주는 도구, 자바 classpath에 있는 모든 패키지를 검색하라는 뜻
* `getTypesAnnotatedWith()` 애노테이션이 붙은 클래스들을 찾을 수 있다.

## 제 7장 퍼시스턴스 프레임워크의 도입

7.1 mybatis 소개

7.1.1 mybatis 사용하기

7.1.2 mybatis 사용 준비



7.2 mybatis 적용

7.2.1 mybatis 구동하기

7.2.2 mybatis 프레임워크의 핵심 컴포넌트

7.2.3 DAO에서 SqlSessionFactory 사용

7.2.4 SQL 맵퍼 파일 작성

7.2.5 ApplicationContext 변경

7.2.6 SqlSessionFactory 객체 준비

7.2.6 mybatis 설정 파일 준비



7.2.7 db.properties 파일 작성
7.3 SQL 맵퍼 파일

7.3.1 SQL 맵퍼 파일 작성

7.3.2 mybatis의 SELECT 결과 캐싱

7.3.3 SQL 문의 입력 매개변수 처리

7.4 mybatis 설정 파일



7.5 로그 출력 켜기

7.5.1 mybatis 설정 파일에 로그 설정 추가

7.5.2 로그 출력 테스트



7.6 동적 SQL의 사용

7.6.1 동적 SQL 엘리먼트

7.6.2 프로젝트 목록 페이지에 정렬 링크 추가

7.6.3 프로젝트 목록 컨트롤러 변경

7.6.4 ProjectDao 인터페이스 변경

7.6.5 엘리먼트의 활용

7.6.6 MySqlProjectDao 클래스 변경

7.6.7 동적으로 생성된 UPDATE 문 확인



7.7 실력 향상 훈련

7.7.1 훈련. 회원 관리에 mybatis 적용

7.8 정리



~652p

## 제 8장 스프링 IoC 컨테이너

8.1 스프링 IoC 컨테이너 사용 준비

8.1.1 의존성 주입(DI)과 역제어(IoC)

8.1.2 Gradle 프로젝트 준비

8.1.3 Gradle 프로젝트를 웹 프로젝트로 만들기

8.1.4 스프링 프레임워크 관련 라이브러리 가져오기

8.1.5 실습 프로젝트 정리

8.1.6 Gradle 빌드



8.2 Gradle 빌드 파일 분석

8.2.1 Gradle 플러그인이란?

8.2.2 Gradle Java 플러그인

8.2.3 jar 작업과 제어 속성 - jar {}

8.2.4 의존 라이브러리를 가져올 저장소 설정 - repositories {}

8.2.5 프로젝트에서 사용할 의존 라이브러리 지정 - dependencies {}

8.2.6 테스트 정보 설정 - test {}

8.2.7 아카이브 파일(.jar) 배포 - uploadArchives {}

8.2.8 Gradle Eclipse 플러그인



8.3 XML 기반 빈 관리 컨테이너

8.3.1 ApplicationContext 인터페이스

8.3.2 스프링 빈 컨테이너 ClassPathXmlApplicationContext 사용

8.3.3 name 속성으로 빈 이름 지정하기

8.3.4 익명 빈 선언



8.4 생성자와 프로퍼티 설정

8.4.1 호출할 생성자 설정

8.4.2 프로퍼티 설정

8.4.3 의 속성을 이용하여 생성자 및 프로퍼티 설정하기



8.5 의존 객체 주입

8.5.1 의존 객체 설정하기

8.5.2 개별 인스턴스 주입하기



8.6 컬렉션 값 주입

8.6.1 배열 프로퍼티의 값 주입

8.6.2 Map과 Properties 값 주입



8.7 팩토리 메서드와 팩토리 빈

8.7.1 스태틱 팩토리 메서드를 이용한 간접 객체 생성

8.7.2 인스턴스 팩토리 메서드를 이용한 간접 객체 생성

8.7.3 스프링 규칙에 따라서 팩토리 빈 만들기



8.8 빈의 범위 설정

8.8.1 싱글톤과 프로토타입



8.9 날짜 값 주입

8.9.1 SimpleDateFormat 클래스와 인스턴스 팩토리 메서드 활용

8.9.2 커스텀 프로퍼티 에디터 활용



8.10 애노테이션을 이용한 의존 객체 자동 주입

8.10.1 @Autowired 적용

8.10.2 @Autowired의 required 속성

8.10.3 @Qualifier로 주입할 객체를 지정하기

8.10.4 @Autowired + @Qualifier = @Resource



8.11 빈 자동 등록

8.11.1 @Component가 붙은 클래스를 자동으로 찾기



8.12 Gradle 적용

8.12.1 Gradle 적용 준비

8.12.2 Gradle 설정에 의존 라이브러리 추가

8.12.3 Gradle 빌드

8.12.4 톰캣 서버에 웹 애플리케이션 배치 및 실행



8.13 스프링 IoC 컨테이너 적용

8.13.1 mybatis 관련 의존 라이브러리 추가

8.13.2 Gradle 빌드

8.14 정리

~835p