## 제 2장 웹 프로그래밍 기초 다지기

Header : 서버가 요청을 처리할 때 참고하라고 클라이언트에서 웹 서버에게 알려주는 정보

* 일반 헤더: 요청이나 응답 모두에 적용할 수 있는 헤더
  * Cache-Control, Transfer-Encoding 등
* 요청/응답 헤더:  요청 또는 응답 중 하나에만 적용하는 헤더
  * Accept-Charset, Referer, Host, User-Agent 등
* 엔티티 헤더: 보내거나 받는 본문 데이터를 설명하는 헤더
    *   Allow, Content-Encoding, Content-Type 등


| 프로토콜                                         | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| FTP(File Transfer Protocol)                      | 클라이언트와 서버 간에 파일을 주고받기 위해 만든 통신 규약   |
| Telnet 프로토콜                                  | 인터넷이나 LAN 상에서 문자 기반으로 원격의 컴퓨터를 제어하기 위해 만든 통신 규약, 요즘은 보안때문에 SSH(Secure Shell) 프로토콜 기반 원격 접속 프로그램을 주로 사용 |
| XMPP(Extexsible Messaging and Presence Protocol) | 인스턴스 메시지 및 사용자의 접속 상태 정보를  교환할 목적으로 만든 통신 규약이며 Google Talk가 이 프로토콜을 기반으로 통신한다. |
| SMPT(Simple Mail Transfer Protocol)              | 인터넷 상에서 메일을 보내기 위한 통신 규약, POP3(Post Office Protocol version3)는 이메일을 가져 오는데 사용하는 통신 규약이며 POP3는 이메일을 가져온 후 서버의 메일을 삭제한다. |
| IMAP(Internet Message Access Protocol)           | POP3와 달리 이메일을 가져온 뒤에 서버의 메일을 지우지 않으며 요즘처럼 여러 대의 장비에서 이메일을 조회하는 경우에 적합하다. 단, POP3에 비해 통신 트래픽이 높은 것이 단점 |
| LDAP(Lightweight Directory Access Protocol)      | 디렉터리 서비스에 등록된 자원들을 찾는 통신 규약이다.        |
| IRC(Internet Relay Chat)                         | 실시간 채팅을 위해 만든 통신 규약이다.                       |

## 제 3장 서블릿 프로그래밍

웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI(Common Gateway Interface)라고 하고, 이렇게 웹 서버에 의해 실행되며 CGI 규칙에 따라서 웹 서버와 데이터를 주고 받도록 작성된 프로그램을 CGI프로그램이라고 한다.

* CGI는 C,C++,Java 등 컴파일 언어는 기계어로 번역된 코드를 바로 실행하기 때문에 실행속도가 빠르지만 수정 시마다 다시 컴파일 및 재배포 해야한다.
* Perl, PHP,Python 등의 스크립트 방식은 실행할 때마다 소스 코드의 문법을 검증하고 해석해야 하기 때문에 실행속도는 느리지만 변경 사항이 발생하면 소스코드를 수정하고 저장만 하면 되므로 편리하다.

Servlet: 자바로 만든 CGI 언어

* 서블릿 컨테이너가 서블릿을 대신하여 CGI규칙에 따라 웹 서버와 데이터를 주고 받는다.

***

`web.xml`: 배치기술서 DD(Deployment Description) 이라고 부르며, 웹 애플리케이션 배치 정보를 담고 있는 파일이다.

* 서블릿을 만들고 DD파일에 배치정보를 등록하지 않으면 서블릿 컨테이너가 서블릿을 찾지 못한다.

GenericServlet : 하위 클래스에게 공통의 필드와 메서드를 상속해 주고자 존재한다(추상클래스)

* 서블릿 클래스가 필요로 하는 init(), destroy(), getServletConfig(), getServletInfo()를 미리 구현하여 상속해 준다.
* GenericServlet을 상속받는다면 service() 만 구현하면 된다.

> http://localhost:9999/Lesson03/calc?a=1&b=2

```java
public class CalculatorServlet extends GenericServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void service(ServletRequest request, ServletResponse response)
			throws ServletException, IOException {
		int a = Integer.parseInt( request.getParameter("a") );
		int b = Integer.parseInt( request.getParameter("b") );

		response.setContentType("text/plain");
		response.setCharacterEncoding("UTF-8");
		PrintWriter writer = response.getWriter();
		writer.println("a=" + a + "," + "b=" + b + "의 계산결과 입니다.");
		writer.println("a + b = " + (a + b));
		writer.println("a - b = " + (a - b));
		writer.println("a * b = " + (a * b));
		writer.println("a / b = " + ((float)a / (float)b));
		writer.println("a % b = " + (a % b));
    }
}
```

* `response.setContentType("text/plain");`: 클라이언트가 출력할 데이터 형식과 문자 집합을 지정, 출력할 데이터가 텍스트이고 별도의 메타 정보가 없는 순수한 텍스트임
* `response.setCharacterEncoding("UTF-8");`: 출력할 데이터의 문자 집합을 지정
* `PrintWriter writer = response.getWriter();`: 클라이언트로 출력할 수 있도록 출력 스트림 객체를 반환

## 제 4장 서블릿과 JDBC

### HttpServlet

```java
	// 생략
	PreparedStatement stmt = null; // insert이므로
	// Statement stmt = null; // select일 때

	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			DriverManager.registerDriver(new com.mysql.jdbc.Driver());
			conn = DriverManager.getConnection(
					"jdbc:mysql://localhost/studydb", //JDBC URL
					"study",	// DBMS 사용자 아이디
					"study");	// DBMS 사용자 암호
			stmt = conn.prepareStatement(
					"INSERT INTO MEMBERS(EMAIL,PWD,MNAME,CRE_DATE,MOD_DATE)"
					+ " VALUES (?,?,?,NOW(),NOW())");
			stmt.setString(1, request.getParameter("email")); // 첫번째 물음표
			stmt.setString(2, request.getParameter("password")); // 두번째 물음표
			stmt.setString(3, request.getParameter("name")); // 세번째 물음표
			stmt.executeUpdate();

			// 리다이렉트를 이용한 리프래시
			//response.sendRedirect("list");
            
			response.setContentType("text/html; charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.println("<html><head><title>회원등록결과</title></head>");
			// meta 태그를 이용한 리프래시
			out.println("<meta http-equiv='Refresh' content='1; url=list'>");
			out.println("<body>");
			out.println("<p>등록 성공입니다!</p>");
			out.println("</body></html>");
			// 리프래시 정보를 응답 헤더에 추가
			//response.addHeader("Refresh", "1;url=list");
            
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}

	}
```

* `HttpServlet`는 `GenericServlet`를 상속받으므로 service()가 아닌 doXXX()를 오버라이딩한다.
* doXXX()는 클라이언트 요청 방식에 따라 GET, POST, PUT 등으로 오버라이딩한다.

* 입력 매개변수의 번호는 1부터 시작한다.
* `response.addHeader("Refresh", "1;url=list");`: 1초 후 list로 이동한다.
* `response.sendRedirect("list");` 응답 결과를 출력하지 않고 이동한다.

| 비교 항목            | Statement                                                    | PreparedStatemen                                             |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 실행 속도            | 질의할 때마다 SQL 문을 컴파일한다.                           | SQL문을 미리 준비하여 컴파일해 둔다. 입력 매개변수 값만 추가하여 서버에 전송한다. 특히 여러 번 반복하여 질의하는 경우, 실행속도가 빠름 |
| 바이너리 데이터 전송 | 불가능                                                       | 가능                                                         |
| 프로그래밍 편의성    | SQL문 안에 입력 매개변수 값이 있어서 SQL 문이 복잡하고 매개변수가 여러 개인 경우 코드 관리가 힘들다 | SQL문과 입력 매개변수가 분리되어 있어 코드 작성이 편하다.    |

***

```java
@SuppressWarnings("serial")
/* 애노테이션을 이용하여 서블릿 배치 정보 설정
 * - 서블릿 초기화 파라미터도 애노테이션으로 처리 
 *
@WebServlet(
  urlPatterns={"/member/update"},
  initParams={
	  @WebInitParam(name="driver",value="com.mysql.jdbc.Driver"),
	  @WebInitParam(name="url",value="jdbc:mysql://localhost/studydb"),
	  @WebInitParam(name="username",value="study"),
	  @WebInitParam(name="password",value="study")
  }
)
*/
public class MemberUpdateServlet extends HttpServlet {
	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;
		try {
			Class.forName(this.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						this.getInitParameter("url"),
						this.getInitParameter("username"),
						this.getInitParameter("password")); 
			stmt = conn.createStatement();
			rs = stmt.executeQuery(
				"SELECT MNO,EMAIL,MNAME,CRE_DATE FROM MEMBERS" + 
				" WHERE MNO=" + request.getParameter("no"));	
			rs.next();
			
			response.setContentType("text/html; charset=UTF-8");
			PrintWriter out = response.getWriter();
			out.println("<html><head><title>회원정보</title></head>");
			out.println("<body><h1>회원정보</h1>");
			out.println("<form action='update' method='post'>");
			out.println("번호: <input type='text' name='no' value='" +
				request.getParameter("no") + "' readonly><br>");
			out.println("이름: <input type='text' name='name'" +
				" value='" + rs.getString("MNAME")  + "'><br>");
			out.println("이메일: <input type='text' name='email'" +
				" value='" + rs.getString("EMAIL")  + "'><br>");
			out.println("가입일: " + rs.getDate("CRE_DATE") + "<br>");
			out.println("<input type='submit' value='저장'>");
			out.println("<input type='button' value='취소'" + 
				" onclick='location.href=\"list\"'>");
			out.println("</form>");
			out.println("</body></html>");
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch(Exception e) {}
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}
	}
	
	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		Connection conn = null;
		PreparedStatement stmt = null;
		try {
			Class.forName(this.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						this.getInitParameter("url"),
						this.getInitParameter("username"),
						this.getInitParameter("password")); 
			stmt = conn.prepareStatement(
					"UPDATE MEMBERS SET EMAIL=?,MNAME=?,MOD_DATE=now()"
					+ " WHERE MNO=?");
			stmt.setString(1, request.getParameter("email"));
			stmt.setString(2, request.getParameter("name"));
			stmt.setInt(3, Integer.parseInt(request.getParameter("no")));
			stmt.executeUpdate();
			
			response.sendRedirect("list");
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}
	}
}
```

* ```java
  @WebServlet(
    urlPatterns={"/member/update"},
    initParams={
  	  @WebInitParam(name="driver",value="com.mysql.jdbc.Driver"),
  	  @WebInitParam(name="url",value="jdbc:mysql://localhost/studydb"),
  	  @WebInitParam(name="username",value="study"),
  	  @WebInitParam(name="password",value="study")
    }
  )
  ```

  : 웹 애노테이션으로 DB연결 설정

  `Class.forName(this.getInitParameter("driver"));` driver에 해당하는 `com.mysql.jdbc.Driver` 가져옴

* `conn = DriverManager.getConnection(`: Driver로 가져온 db연결하여 사용



### 컨텍스트 초기화 매개변수

: 각 서블릿마다 JDBC 드라이버와 데이터베이스 연결에 대한 정보를 설정하지 않고 같은 웹 애플리케이션에 소속된 서블릿들이 공유하는 서블릿컨텍스트를 사용한다.

> web.xml

```xml
<!-- 컨텍스트 초기화 파라미터 -->
	<context-param>
		<param-name>driver</param-name>
		<param-value>com.mysql.jdbc.Driver</param-value>
	</context-param>
	<context-param>
		<param-name>url</param-name>
		<param-value>jdbc:mysql://localhost/studydb</param-value>
	</context-param>
	<context-param>
		<param-name>username</param-name>
		<param-value>study</param-value>
	</context-param>
	<context-param>
		<param-name>password</param-name>
		<param-value>study</param-value>
	</context-param>
```

```java
// 생략
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password")); 
			stmt = conn.createStatement();
// 생략
```

### 필터

: 서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술

```java
package spms.filters;

// 생략

@WebFilter(
	urlPatterns="/*",
	initParams={
		@WebInitParam(name="encoding",value="UTF-8")
	})
public class CharacterEncodingFilter implements Filter{
	FilterConfig config;
	
	@Override
	public void init(FilterConfig config) throws ServletException {
		this.config = config;
	}
	
	@Override
	public void doFilter(
			ServletRequest request, ServletResponse response,
			FilterChain nextFilter) throws IOException, ServletException {
		request.setCharacterEncoding(config.getInitParameter("encoding"));
        /* 서블릿이 실행되기 전에 해야 할 작업 */
        
        // 다음 필터를 호출, 더이상 필터가 없다면 서블릿의 service()가 호출됨
		nextFilter.doFilter(request, response);
        
        /* 서블릿이 실행한 후, 클라이언트에게 응답하기 전에 해야할 작업 */
	}

	@Override
	public void destroy() {}
}

```

> web.xml

```xml
	<!-- 필터 선언 --> 
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>spms.filters.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
	
	<!-- 필터 URL 매핑 -->
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
```

* `<url-pattern>/*</url-pattern>`: 모든 요청에 대해 필터 적용

## 제 5장 MVC 아키텍처

**JSP 프리컴파일**: 서버에 배치할 때 JSP 파일에 대해 자바 서블릿 클래스를 미리 생성하기도 한다. JSP 실행 요청이 들어 왔을 때, 곧바로 서블릿을 호출할 수 있어, JSP를 실행할 때마다 JSP 파일이 변경되었는지, JSP 파일에 대해 서블릿 파일이 있는지 매번 검사할 필요가 없어 컴파일하는 과정이 없으므로 실행속도가 빠르다.

단, JSP를 편집하면 서버를 다시 시작해야한다.

#### JSP 전용 태그 - 지시자

`<%@ 지시자 속성="값" 속성="값" ... %>`

* page: JSP페이지와 관련된 속성을 정의할 때 사용

  * ```jsp
    <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
    <!-- pageEncoding: 출력할 데이터 타입을 지정 -->
    ```

* taglib

* include

#### JSP 전용 태그 - 스크립트릿

`<@ 자바 코드 @>`

#### JSP 내장 객체

: 스트립트릿이나 표현식을 작성할 때 별도의 선언 없이 사용가능한 자바 객체

* request, response, pageContext, session, application, config, out, page, exception

#### JSP 전용 태그 - 선언문

`<%! 멤버 변수 및 메서드 선언 %>`

#### JSP 전용 태그 - 표현식

`<%= 결과를 반환하는 자바 표현식 %>`

```jsp
<input type="text" name="v1" size="4" value="<%=v1%>"> 
<option value="+" <%=selected[0]%>>+</option>
```

### 서블릿에서 뷰 분리하기

서블릿(Model+Controller) -> JSP(View)

#### 값 객체(VO) = 데이터 수송 객체(DTO)

: 데이터베이스에서 가져온 정보를 JSP 페이지에 전달할 목적으로 정보를 담은 객체

#### 회원 목록

```java
// UI 출력 코드를 제거하고, UI 생성 및 출력을 JSP에게 위임한다.
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		Statement stmt = null;
		ResultSet rs = null;

		try {
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password")); 
			stmt = conn.createStatement();
			rs = stmt.executeQuery(
					"SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
					" FROM MEMBERS" +
					" ORDER BY MNO ASC");
			
			response.setContentType("text/html; charset=UTF-8");
			ArrayList<Member> members = new ArrayList<Member>();
			
			// 데이터베이스에서 회원 정보를 가져와 Member에 담는다.
			// 그리고 Member객체를 ArrayList에 추가한다.
			while(rs.next()) {
				members.add(new Member()
							.setNo(rs.getInt("MNO"))
							.setName(rs.getString("MNAME"))
							.setEmail(rs.getString("EMAIL"))
							.setCreatedDate(rs.getDate("CRE_DATE"))	);
			}
			
			// request에 회원 목록 데이터 보관한다.
			request.setAttribute("members", members);
			
			// JSP로 출력을 위임한다!!
			RequestDispatcher rd = request.getRequestDispatcher(
					"/member/MemberList.jsp");
			rd.include(request, response);
			
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch(Exception e) {}
			try {if (stmt != null) stmt.close();} catch(Exception e) {}
			try {if (conn != null) conn.close();} catch(Exception e) {}
		}

	}
}
```

```jsp
<%@page import="spms.vo.Member"%>
<%@page import="java.util.ArrayList"%>
<%@ page 
	language="java" 
	contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>회원 목록</title>
</head>
<body>
<h1>회원목록</h1>
<p><a href='add'>신규 회원</a></p>
<%
ArrayList<Member> members = (ArrayList<Member>)request.getAttribute(
								"members");
for(Member member : members) {
%>
<%=member.getNo()%>,
<a href='update?no=<%=member.getNo()%>'><%=member.getName()%></a>,
<%=member.getEmail()%>,
<%=member.getCreatedDate()%>
<a href='delete?no=<%=member.getNo()%>'>[삭제]</a><br>
<%} %>
</body>
</html>
```

**포워드(forward)**: 제어권을 넘기고 안돌아옴, ex) 예외 발생

```java
// 생략
	} catch (Exception e) {
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
			rd.forward(request, response);
// 생략
```

```jsp
<%@ page 
	language="java" 
	contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>시스템 오류!</title>
</head>
<body>
<p>요청을 처리하는 중에 문제가 발생하였습니다. 잠시 후에 다시 요청하시기 바랍니다.
만약 계속해서 이 문제가 발생된다면 시스템 운영팀(사내번호: 8282)에 연락하기 바랍니다.</p>
</body>
</html>
```

**인클루드(include)**: 제어권을 넘기고 그 서블릿이 작업이 끝나면 돌아옴, ex) Header, Tail

```jsp
<jsp:include page="/Header.jsp"/>
<!-- 생략 -->
<jsp:include page="/Tail.jsp"/>
```

### 데이터 보관소

데이터를 공유하기 위한 서블릿 기술

```java
보관소 객체.setAttribute(키, 값); // 값 저장
보관소 객체.getAttribute(키); // 값 저장
```

#### ServletContext

: 웹 애플리케이션이 시작될 때 생성되어 웹 애플리케이션이 종료될 때까지 유지된다. 

* application 변수를 통해 참조

```java
@SuppressWarnings("serial")
public class AppInitServlet extends HttpServlet {

	@Override
	public void init(ServletConfig config) throws ServletException {
		System.out.println("AppInitServlet 준비…");
		super.init(config);
		try {
			ServletContext sc = this.getServletContext();
			Class.forName(sc.getInitParameter("driver"));
			Connection conn = DriverManager.getConnection(
						sc.getInitParameter("url"),
						sc.getInitParameter("username"),
						sc.getInitParameter("password"));
			
			sc.setAttribute("conn", conn);
		} catch(Throwable e) {
			throw new ServletException(e);
		}
	}
	
	@Override
	public void destroy() {
		System.out.println("AppInitServlet 마무리...");
		super.destroy();
		Connection conn = 
				(Connection)this.getServletContext().getAttribute("conn"); 
		try {
			if (conn != null && conn.isClosed() == false) {
				conn.close();
			}
		} catch (Exception e) {}
		
	}
}
```

* `sc.setAttribute("conn", conn);`: 데이터베이스 커넥션 객체를 보관소에 저장해서 모든 웹 애플리케이션에서 사용가능하도록 처리

```xml
	<!-- 서블릿 선언 -->
	<servlet>
    <servlet-name>AppInitServlet</servlet-name>
    <servlet-class>spms.servlets.AppInitServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
```

* `<load-on-startup>`: 클라이언트 요청이 없더라도 웹 애플리케이션이 시작되면 자동으로 실행

#### HttpSession

: 클라이언트의 최초 요청 시 생성되어 브라우저를 닫을 때까지 유지, 보통 로그인할 때 생성하고 로그아웃하면 비운다.

* session 변수를 통해 참조

```java
@WebServlet("/auth/login")
public class LogInServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		RequestDispatcher rd = request.getRequestDispatcher(
				"/auth/LogInForm.jsp");
		rd.forward(request, response);
	}
	
	@Override
	protected void doPost(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			ServletContext sc = this.getServletContext();
			conn = (Connection) sc.getAttribute("conn");  
			stmt = conn.prepareStatement(
					"SELECT MNAME,EMAIL FROM MEMBERS"
					+ " WHERE EMAIL=? AND PWD=?");
			stmt.setString(1, request.getParameter("email"));
			stmt.setString(2, request.getParameter("password"));
			rs = stmt.executeQuery();
			if (rs.next()) {
				Member member = new Member()
						.setEmail(rs.getString("EMAIL"))
						.setName(rs.getString("MNAME"));
				HttpSession session = request.getSession();
				session.setAttribute("member", member);
				
				response.sendRedirect("../member/list");
			} else {
				RequestDispatcher rd = request.getRequestDispatcher(
						"/auth/LogInFail.jsp");
				rd.forward(request, response);
			}
		} catch (Exception e) {
			throw new ServletException(e);
			
		} finally {
			try {if (rs != null) rs.close();} catch (Exception e) {}
			try {if (stmt != null) stmt.close();} catch (Exception e) {}
		}
	}
}
```

* 로그인 성공일 경우 Member 객체를 HttpSession에 보관한다.

```jsp
<%@page import="spms.vo.Member"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
Member member = (Member)session.getAttribute("member");
%>
<div style="background-color:#00008b;color:#ffffff;height:20px;padding: 5px;">
SPMS(Simple Project Management System)
<span style="float:right;">
<%=member.getName()%>
<a style="color:white;" 
  href="<%=request.getContextPath()%>/auth/logout">로그아웃</a>
</span>
</div>
```

* JSP 내장 객체 session을 사용하여 member라는 키로 저장된 값을 꺼낸다.

```java
@WebServlet("/auth/logout")
public class LogOutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		session.invalidate();
		
		response.sendRedirect("login");
	}
}
```

* `session.invalidate();`: 세션 객체 무효화한다.

#### ServletRequest

: 클라이언트의 요청이 들어올 때 생성되어, 클라이언트에게 응답할 때까지 유지, 보통 포워딩이나 인클루딩하는 서블릿들 사이에서 값을 공유한다.

* request 변수를 통해 참조

```java
// 생략
	@Override
	protected void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		RequestDispatcher rd = request.getRequestDispatcher(
				"/auth/LogInForm.jsp");
		rd.forward(request, response);
	}
// 생략
```

#### JspContext의 활용

: JSP 페이지를 실행하는 동안만 유지

* pageContext 변수를 통해 참조

```jsp
<body>
<jsp:include page="/Header.jsp"/>
<h1>회원목록</h1>
```

* 태그 핸들러를 사용하기 위해 필요하다.

### JSP 액션 태그

`<jsp:useBean>`: 보관소에서 자바 인스턴스를 꺼내거나, 자바 인스턴스를 새로 만들어 보관소에 저장하는 코드를 생성한다. 자바 인스턴스를 자바빈(JavaBean)이라고 한다.

```jsp
<jsp:useBean id="members"
  scope="request"
  class="java.util.ArrayList" 
  type="java.util.ArrayList<spms.vo.Member>"/>
<jsp:useBean id="member"
  scope="session"
  class="spms.vo.Member"/>
```

* scope: 보관소를 의미, request일 경우 servletRequest 보관소
* type: 참조변수를 선언할 타입의 이름

`<jsp:setProperty>`: 자바 빈의 프로퍼티 값을 설정, 자바 객체의 setter 메서드를 호출하는 코드 생성

`<jsp:getProperty>`: 자바 빈의 프로퍼티 값을 꺼냄, 자바 객체의 getter 메서드를 호출하는 코드 생성

`<jsp:param>`: `<jsp:include>`,`<jsp:forward>`의 자식 태그로 사용할 수 있음, ServletRequest  객체에 매개변수를 추가하는 코드를 생성

### EL(Expression Language)

`${객체이름.프로퍼티}` 또는 `${객체이름["프로퍼티"]}`

> `${member.no}`, `${member["no"]}`

* EL을 사용할 경우 `<jsp:useBean>` 액션 태그를 사용할 필요도 없으며 `<%=member.getNo()%>` 보다 간결하다.

* EL안에서 값, 연산 모두 가능

```jsp
${"테스트"} // 테스트
${1} // 1
${1+1} // 2
번호: <input type='text' name='no' value='${member.no}' readonly><br>
이름: <input type='text' name='name' value='${member.name}'><br>
이메일: <input type='text' name='email' value='${member.email}'><br>
가입일: ${member.createdDate}<br>
```

### JSTL(Java Standard Tab Library)

태그 라이브러리 선언: `<%@ tablib uri="사용할 태그의 라이브러리 URI" prefix="접두사" %>`

| 태그 라이브러리 | 접두사 | 네임스페이스의 URI 식별자               |
| --------------- | ------ | --------------------------------------- |
| Core            | c      | http://java.sun.com/jsp/jstl/core       |
| XML             | x      | http://java.sun.com/jsp/jstl/xml        |
| \|18N           | fmt    | http://java.sun.com/jsp/jstl/fmt        |
| Database        | sql    | http://java.sun.com/jsp/jstl/sql        |
| Functions       | fn     | http://java. sun.com/jsp/jstl/functions |

* `<c:out value="출력할 값">기본값</c:out>`

* `<c:set value="값" target="${객체}" property="propertyName" scope="request" var="변수 명" />`
* `<c:if>`: 조건
* `<c:choose>`: switch case문
* `<c:forEach>`: 반복
* `<c:forTokens>`: 문자열을 특정 구분자로 분리하여 반복문을 돌림
* `<c:url>`: url 생성

나머진 JSP.md 파일에서 찾거나 구글링

```jsp
<!-- <%@page import="spms.vo.Member"%> -->
<!-- <%@page import="java.util.ArrayList"%> -->

<%@ page 
  language="java" 
  contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>      
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>회원 목록</title>
</head>
<body>
<jsp:include page="/Header.jsp"/>
<h1>회원목록</h1>
<p><a href='add.do'>신규 회원</a></p>
<!-- <jsp:useBean id="members"
  scope="request"
  class="java.util.ArrayList" 
  type="java.util.ArrayList<spms.vo.Member>"/> -->
<c:forEach var="member" items="${members}"> 
${member.no},
<a href='update.do?no=${member.no}'>${member.name}</a>,
${member.email},
${member.createdDate}
<a href='delete.do?no=${member.no}'>[삭제]</a><br>
</c:forEach>
<jsp:include page="/Tail.jsp"/>
</body>
</html>
```

### DAO(Data Acess Object) 분리

: 데이터베이스와 연동하여 데이터를 처리하는 부분을 분리

> MemberDAO.java

```java
// 생략
public class MemberDao {
  Connection connection;

  public void setConnection(Connection connection) {
    this.connection = connection;
  }

  public List<Member> selectList() throws Exception {
    Statement stmt = null;
    ResultSet rs = null;

    try {
      stmt = connection.createStatement();
      rs = stmt.executeQuery(
          "SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
              " FROM MEMBERS" +
          " ORDER BY MNO ASC");

      ArrayList<Member> members = new ArrayList<Member>();

      while(rs.next()) {
        members.add(new Member()
        .setNo(rs.getInt("MNO"))
        .setName(rs.getString("MNAME"))
        .setEmail(rs.getString("EMAIL"))
        .setCreatedDate(rs.getDate("CRE_DATE"))	);
      }

      return members;

    } catch (Exception e) {
      throw e;

    } finally {
      try {if (rs != null) rs.close();} catch(Exception e) {}
      try {if (stmt != null) stmt.close();} catch(Exception e) {}
    }
  }
}
// 생략
```

* selectList() 리턴 타입이 `List` 이다.

* ```java
    Connection connection;
  
    public void setConnection(Connection connection) {
      this.connection = connection;
    }
  ```

  * 작업에 필요한 객체를 외부로부터 주입 받는 것을 '의존성 주입(DI)' 또는 '역제여(IoC, Invension of Control)'이라고 부른다.

> MemberListServlet.java

```java
// MemberDao 사용  
@WebServlet("/member/list")
public class MemberListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			ServletContext sc = this.getServletContext();
			Connection conn = (Connection) sc.getAttribute("conn"); 
			
			MemberDao memberDao = new MemberDao();
			memberDao.setConnection(conn);
			
			request.setAttribute("members", memberDao.selectList());
			
			response.setContentType("text/html; charset=UTF-8");
			RequestDispatcher rd = request.getRequestDispatcher(
					"/member/MemberList.jsp");
			rd.include(request, response);
			
		} catch (Exception e) {
			e.printStackTrace();
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
			rd.forward(request, response);
		}
	}
}
```

* MemberListServlet 클래스에는 데이터베이스와 관련된 코드가 존재하지 않고 MemberDAO로 이관됨

### 리스너

서블릿 컨테이너는 웹 애플리케이션의 상태를 모니터링 할 수 있도록 웹 애플리케이션 시작에서 종료까지 주요한 사건에 대해 알림 기능을 제공한다. 이런 알림 기능을 이용하고 싶다면, 규칙에 따라 객체를 만들어 DD파일(web.xml)에 등록하면 되고 이렇게 사건이 발생했을 때 알림을 받는 객체릴 '리스너(Listener)'라고 부른다.

#### ServletContextListener

: 웹 애플리케이션이 시작하거나 종료할 때 이벤트

* 웹 애플리케이션이 시작, 종료할 때 DAO 객체를 준비하여 ServletContext에 저장한다.

> ContextLoaderListener.java

```java
@WebListener
public class ContextLoaderListener implements ServletContextListener {
  Connection conn;
  
  @Override
  public void contextInitialized(ServletContextEvent event) {
    try {
      ServletContext sc = event.getServletContext();

      Class.forName(sc.getInitParameter("driver"));
      conn = DriverManager.getConnection(
          sc.getInitParameter("url"),
          sc.getInitParameter("username"),
          sc.getInitParameter("password"));

      MemberDao memberDao = new MemberDao();
      memberDao.setConnection(conn);

      sc.setAttribute("memberDao", memberDao);

    } catch(Throwable e) {
      e.printStackTrace();
    }
  }

  @Override
  public void contextDestroyed(ServletContextEvent event) {
    try {
      conn.close();
    } catch (Exception e) {}
  }
}
```

* `contextInitialized`: 웹 애플리케이션 시작

* `contextDestroyed`: 종료

* `Connection conn = (Connection) sc.getAttribute("conn"); ` -> 제거

* ```java
  ServletContext sc = this.getServletContext();
  // Connection conn = (Connection) sc.getAttribute("conn"); 
  
  // MemberDao memberDao = new MemberDao();
  // memberDao.setConnection(conn);
  MemberDao memberDao = (MemberDao)sc.getAttribute("memberDao");
  ```

### DB 커넥션풀



5.12.2 DB 커넥션풀 만들기

5.12.3 MemberDAO에 DB 커넥션풀 적용하기

5.12.4 ContextLoaderListener에서 DBConnectionPool 생성 및 DAO에 주입



5.13 DataSource와 JNDI

5.13.1 javax.sql 확장 패키지

5.13.2 DataSource

5.13.3 DataSource의 적용

5.13.4 서버에서 제공하는 DataSource 사용하기



~424p

## 제 6장 미니 MVC 프레임워크 만들기

6.1 프런트 컨트롤러의 도입

6.1.1 프런트 컨트롤러 패턴

6.1.2 프런트 컨트롤러를 통해 회원 목록 출력

6.1.3 프런트 컨트롤러 만들기

6.1.4 MemberListServlet을 페이지 컨트롤러로 만들기

6.1.5 프런트 컨트롤러를 통한 회원 목록 페이지 요청

6.1.6 MemberAddServlet을 페이지 컨트롤러로 만들기

6.1.7 회원 등록 테스트



6.2 페이지 컨트롤러의 진화

6.2.1 프런트 컨트롤러와 페이지 컨트롤러의 호출 규칙 정의

6.2.2 호출 규칙 정의

6.2.3 페이지 컨트롤러를 위한 인터페이스 정의

6.2.4 페이지 컨트롤러 'MemberListServlet'을 일반 클래스로 전환

6.2.5 프런트 컨트롤러 변경

6.2.6 회원 등록 페이지 컨트롤러에 Controller 규칙 적용하기

6.2.7 회원 등록 요청을 처리하기 위해 DispatcherServlet 변경

6.2.8 회원 등록 페이지의 실행 테스트



6.3 DI를 이용한 빈 의존성 관리

6.3.1 의존 객체의 관리

6.3.2 의존 객체를 외부에서 주입

6.3.3 MemberDao와 DataSource

6.3.4 MemberListController에 MemberDao 주입

6.3.5 페이지 컨트롤러 객체들을 준비

6.3.6 프런트 컨트롤러의 변경

6.3.7 인터페이스를 활용하여 공급처를 다변화 하자

6.3.8 MemberDao 인터페이스 정의



6.4 리플랙션 API를 이용하여 프런트 컨트롤러 개선하기

6.4.1 신규 회원 정보 추가 자동화

6.4.2 DataBinding 인터페이스 정의

6.4.3 페이지 컨트롤러의 DataBinding 구현

6.4.4 프런트 컨트롤러의 변경

6.4.5 ServletRequestDataBinder 클래스 생성

6.4.6 리플랙션 API



6.5 프로퍼티를 이용한 객체 관리

6.5.1 실습 시나리오

6.5.2 프로퍼티 파일 작성

6.5.3 ApplicationContext 클래스

6.5.4 ContextLoaderListener 변경

6.5.5 web.xml 파일에 프로퍼티 경로 정보 설정

6.5.6 DispatcherServlet 변경



6.6 애노테이션을 이용한 객체 관리

6.6.1 애노테이션 활용

6.6.2 애노테이션 정의

6.6.3 애노테이션 적용

6.6.4 프로퍼티 파일 변경

6.6.5 ApplicationContext 변경

6.6.6 Reflections 라이브러리 준비



6.7 실력 향상 훈련

6.7.1 데이터베이스 모델

6.7.2 프로젝트 관리 시스템

6.7.3 훈련 1 프로젝트 목록 페이지 구현

6.7.4 훈련 2 프로젝트 등록 구현

6.7.5 훈련 3 프로젝트 변경 구현

6.7.6 훈련 4 프로젝트 삭제 구현

6.7.7 메뉴의 추가

6.8 정리

~555p

## 제 7장 퍼시스턴스 프레임워크의 도입

7.1 mybatis 소개

7.1.1 mybatis 사용하기

7.1.2 mybatis 사용 준비



7.2 mybatis 적용

7.2.1 mybatis 구동하기

7.2.2 mybatis 프레임워크의 핵심 컴포넌트

7.2.3 DAO에서 SqlSessionFactory 사용

7.2.4 SQL 맵퍼 파일 작성

7.2.5 ApplicationContext 변경

7.2.6 SqlSessionFactory 객체 준비

7.2.6 mybatis 설정 파일 준비



7.2.7 db.properties 파일 작성
7.3 SQL 맵퍼 파일

7.3.1 SQL 맵퍼 파일 작성

7.3.2 mybatis의 SELECT 결과 캐싱

7.3.3 SQL 문의 입력 매개변수 처리

7.4 mybatis 설정 파일



7.5 로그 출력 켜기

7.5.1 mybatis 설정 파일에 로그 설정 추가

7.5.2 로그 출력 테스트



7.6 동적 SQL의 사용

7.6.1 동적 SQL 엘리먼트

7.6.2 프로젝트 목록 페이지에 정렬 링크 추가

7.6.3 프로젝트 목록 컨트롤러 변경

7.6.4 ProjectDao 인터페이스 변경

7.6.5 엘리먼트의 활용

7.6.6 MySqlProjectDao 클래스 변경

7.6.7 동적으로 생성된 UPDATE 문 확인



7.7 실력 향상 훈련

7.7.1 훈련. 회원 관리에 mybatis 적용

7.8 정리



~652p

## 제 8장 스프링 IoC 컨테이너

8.1 스프링 IoC 컨테이너 사용 준비

8.1.1 의존성 주입(DI)과 역제어(IoC)

8.1.2 Gradle 프로젝트 준비

8.1.3 Gradle 프로젝트를 웹 프로젝트로 만들기

8.1.4 스프링 프레임워크 관련 라이브러리 가져오기

8.1.5 실습 프로젝트 정리

8.1.6 Gradle 빌드



8.2 Gradle 빌드 파일 분석

8.2.1 Gradle 플러그인이란?

8.2.2 Gradle Java 플러그인

8.2.3 jar 작업과 제어 속성 - jar {}

8.2.4 의존 라이브러리를 가져올 저장소 설정 - repositories {}

8.2.5 프로젝트에서 사용할 의존 라이브러리 지정 - dependencies {}

8.2.6 테스트 정보 설정 - test {}

8.2.7 아카이브 파일(.jar) 배포 - uploadArchives {}

8.2.8 Gradle Eclipse 플러그인



8.3 XML 기반 빈 관리 컨테이너

8.3.1 ApplicationContext 인터페이스

8.3.2 스프링 빈 컨테이너 ClassPathXmlApplicationContext 사용

8.3.3 name 속성으로 빈 이름 지정하기

8.3.4 익명 빈 선언



8.4 생성자와 프로퍼티 설정

8.4.1 호출할 생성자 설정

8.4.2 프로퍼티 설정

8.4.3 의 속성을 이용하여 생성자 및 프로퍼티 설정하기



8.5 의존 객체 주입

8.5.1 의존 객체 설정하기

8.5.2 개별 인스턴스 주입하기



8.6 컬렉션 값 주입

8.6.1 배열 프로퍼티의 값 주입

8.6.2 Map과 Properties 값 주입



8.7 팩토리 메서드와 팩토리 빈

8.7.1 스태틱 팩토리 메서드를 이용한 간접 객체 생성

8.7.2 인스턴스 팩토리 메서드를 이용한 간접 객체 생성

8.7.3 스프링 규칙에 따라서 팩토리 빈 만들기



8.8 빈의 범위 설정

8.8.1 싱글톤과 프로토타입



8.9 날짜 값 주입

8.9.1 SimpleDateFormat 클래스와 인스턴스 팩토리 메서드 활용

8.9.2 커스텀 프로퍼티 에디터 활용



8.10 애노테이션을 이용한 의존 객체 자동 주입

8.10.1 @Autowired 적용

8.10.2 @Autowired의 required 속성

8.10.3 @Qualifier로 주입할 객체를 지정하기

8.10.4 @Autowired + @Qualifier = @Resource



8.11 빈 자동 등록

8.11.1 @Component가 붙은 클래스를 자동으로 찾기



8.12 Gradle 적용

8.12.1 Gradle 적용 준비

8.12.2 Gradle 설정에 의존 라이브러리 추가

8.12.3 Gradle 빌드

8.12.4 톰캣 서버에 웹 애플리케이션 배치 및 실행



8.13 스프링 IoC 컨테이너 적용

8.13.1 mybatis 관련 의존 라이브러리 추가

8.13.2 Gradle 빌드

8.14 정리

~835p